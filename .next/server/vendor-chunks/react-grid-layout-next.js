"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-grid-layout-next";
exports.ids = ["vendor-chunks/react-grid-layout-next"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridItem.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/GridItem.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\n/* harmony import */ var react_resizable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-resizable */ \"(ssr)/./node_modules/react-resizable/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\");\n/* harmony import */ var _calculateUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\");\n\n\n\n\n\n\n\nconst GridItem = (props) => {\n    const [resizing, setResizing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [dragStart, setDragStart] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [className, setClassName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.className || \"\");\n    const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    let { cancel = \"\", handle = \"\", minH = 1, minW = 1, maxH = Infinity, maxW = Infinity, transformScale = 1, resizeHandles, resizeHandle } = props;\n    const moveDroppingItem = (prevProps) => {\n        const { droppingPosition } = props;\n        if (!droppingPosition)\n            return;\n        const node = elementRef.current;\n        // Can't find DOM node (are we unmounted?)\n        if (!node)\n            return;\n        const prevDroppingPosition = prevProps.droppingPosition || {\n            left: 0,\n            top: 0\n        };\n        const shouldDrag = (dragging && droppingPosition.left !== prevDroppingPosition.left) ||\n            droppingPosition.top !== prevDroppingPosition.top;\n        if (!dragging) {\n            onDragStart(droppingPosition.e, {\n                node,\n                deltaX: droppingPosition.left,\n                deltaY: droppingPosition.top\n            });\n        }\n        else if (shouldDrag) {\n            const deltaX = droppingPosition.left - dragging.left;\n            const deltaY = droppingPosition.top - dragging.top;\n            onDrag(droppingPosition.e, {\n                node,\n                deltaX,\n                deltaY\n            });\n        }\n    };\n    // TODO\n    // setEffect((moveDroppingItem())=>[droppingPosition])\n    const getPositionParams = (p = props) => {\n        return {\n            cols: p.cols,\n            containerPadding: p.containerPadding,\n            containerWidth: p.containerWidth,\n            margin: p.margin,\n            maxRows: p.maxRows,\n            rowHeight: p.rowHeight\n        };\n    };\n    /**\n     * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n     * well when server rendering, and the only way to do that properly is to use percentage width/left because\n     * we don't know exactly what the browser viewport is.\n     * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n     * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n     *\n     * @param  {Object} pos Position object with width, height, left, top.\n     * @return {Object}     Style object.\n     */\n    const createStyle = (pos) => {\n        const { usePercentages, containerWidth, useCSSTransforms } = props;\n        let style;\n        // CSS Transforms support (default)\n        if (useCSSTransforms) {\n            style = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.setTransform)(pos);\n        }\n        else {\n            // top,left (slow)\n            style = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.setTopLeft)(pos);\n            // This is used for server rendering.\n            if (usePercentages) {\n                if (containerWidth == null) {\n                    throw new Error(\"Container width is missing!\");\n                }\n                style.left = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.perc)(pos.left / containerWidth);\n                style.width = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.perc)(pos.width / containerWidth);\n            }\n        }\n        return style;\n    };\n    /**\n     * Mix a Draggable instance into a child.\n     * @param  {Element} child    Child element.\n     * @return {Element}          Child wrapped in Draggable.\n     */\n    const mixinDraggable = (child, isDraggable) => {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_draggable__WEBPACK_IMPORTED_MODULE_2__.DraggableCore, { disabled: !isDraggable, onStart: onDragStart, onDrag: onDrag, onStop: onDragStop, handle: props.handle, cancel: \".react-resizable-handle\" + (props.cancel ? \",\" + props.cancel : \"\"), scale: props.transformScale, nodeRef: elementRef, children: child }));\n    };\n    /**\n     * Mix a Resizable instance into a child.\n     * @param  {Element} child    Child element.\n     * @param  {Object} position  Position object (pixel values)\n     * @return {Element}          Child wrapped in Resizable.\n     */\n    const mixinResizable = (child, position, isResizable) => {\n        const positionParams = getPositionParams();\n        // This is the max possible width - doesn't go to infinity because of the width of the window\n        const maxWidth = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemPosition)(positionParams, 0, 0, 0, props.cols - props.x, // TODO types\n        0).width;\n        // Calculate min/max constraints using our min & maxes\n        const mins = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemPosition)(positionParams, 0, 0, 0, minW, minH);\n        const maxes = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemPosition)(positionParams, 0, 0, 0, maxW, maxH);\n        const minConstraints = [mins.width, mins.height];\n        const maxConstraints = [\n            Math.min(maxes.width, maxWidth),\n            Math.min(maxes.height, Infinity)\n        ];\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_resizable__WEBPACK_IMPORTED_MODULE_3__.Resizable\n        // These are opts for the resize handle itself\n        , { \n            // These are opts for the resize handle itself\n            draggableOpts: {\n                disabled: !isResizable\n            }, className: isResizable ? undefined : \"react-resizable-hide\", width: position.width, height: position.height, minConstraints: minConstraints, maxConstraints: maxConstraints, onResizeStop: onResizeStop, onResizeStart: onResizeStart, onResize: onResize, transformScale: transformScale, resizeHandles: resizeHandles, handle: resizeHandle, children: child }));\n    };\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    const onDragStart = (e, { node }) => {\n        const { onDragStart } = props;\n        if (!onDragStart)\n            return;\n        const newPosition = { top: 0, left: 0 };\n        // TODO: this wont work on nested parents\n        const { offsetParent } = node;\n        if (!offsetParent)\n            return;\n        const parentRect = offsetParent.getBoundingClientRect();\n        const clientRect = node.getBoundingClientRect();\n        const cLeft = clientRect.left / transformScale;\n        const pLeft = parentRect.left / transformScale;\n        const cTop = clientRect.top / transformScale;\n        const pTop = parentRect.top / transformScale;\n        newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n        newPosition.top = cTop - pTop + offsetParent.scrollTop;\n        setDragging(newPosition);\n        // Call callback with this data\n        const { x, y } = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcXY)(getPositionParams(), newPosition.top, newPosition.left, props.w, // TODO types\n        props.h // TODO types\n        );\n        setDragStart({ x, y });\n        return onDragStart.call(undefined, {\n            i: props.i,\n            x: x,\n            y: y,\n            data: {\n                e,\n                node,\n                newPosition\n            }\n        });\n    };\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    const onDrag = (e, { node, deltaX, deltaY }) => {\n        const { onDrag } = props;\n        if (!onDrag)\n            return;\n        if (!dragging) {\n            throw new Error(\"onDrag called before onDragStart.\");\n        }\n        let top = dragging.top + deltaY;\n        let left = dragging.left + deltaX;\n        const { isBounded, i, w, h, containerWidth } = props;\n        const positionParams = getPositionParams();\n        // Boundary calculations; keeps items within the grid\n        if (isBounded) {\n            const { offsetParent } = node;\n            if (offsetParent) {\n                const { margin, rowHeight } = props;\n                const colWidth = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridColWidth)(positionParams);\n                let rowHeightNumber = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.resolveRowHeight)(rowHeight, colWidth);\n                const bottomBoundary = offsetParent.clientHeight -\n                    (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemWHPx)(h, rowHeightNumber, margin[1]);\n                top = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.clamp)(top, 0, bottomBoundary);\n                const rightBoundary = containerWidth - (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemWHPx)(w, colWidth, margin[0]);\n                left = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.clamp)(left, 0, rightBoundary);\n            }\n        }\n        const newPosition = { top, left };\n        setDragging(newPosition);\n        // Call callback with this data\n        const { x, y } = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcXY)(positionParams, top, left, w, h);\n        return onDrag.call(undefined, {\n            i,\n            x: x,\n            y: y,\n            data: {\n                e,\n                node,\n                newPosition\n            }\n        });\n    };\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    const onDragStop = (e, { node }) => {\n        const { onDragStop } = props;\n        if (!onDragStop)\n            return;\n        if (!dragging) {\n            throw new Error(\"onDragEnd called before onDragStart.\");\n        }\n        const { w, h, i } = props;\n        const { left, top } = dragging;\n        const newPosition = { top, left };\n        const { x, y } = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcXY)(getPositionParams(), top, left, w, h);\n        let change = dragStart?.x !== x || dragStart?.y !== y;\n        setDragging(undefined);\n        setDragStart(undefined);\n        return onDragStop.call(undefined, {\n            i,\n            x: x,\n            y: y,\n            data: {\n                e,\n                node,\n                newPosition,\n                change\n            }\n        });\n    };\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    const onResizeStop = (e, callbackData) => {\n        onResizeHandler(e, callbackData, \"onResizeStop\");\n    };\n    /**\n     * onResizeStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    const onResizeStart = (e, callbackData) => {\n        onResizeHandler(e, callbackData, \"onResizeStart\");\n    };\n    /**\n     * onResize event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    const onResize = (e, callbackData) => {\n        onResizeHandler(e, callbackData, \"onResize\");\n    };\n    /**\n     * Wrapper around drag events to provide more useful data.\n     * All drag events call the function with the given handler name,\n     * with the signature (index, x, y).\n     *\n     * @param  {String} handlerName Handler name to wrap.\n     * @return {Function}           Handler function.\n     */\n    const onResizeHandler = (e, { node, size }, handlerName) => {\n        const handler = props[handlerName];\n        if (!handler)\n            return;\n        const { cols, x, y, i } = props;\n        // Get new XY\n        let { w, h } = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcWH)(getPositionParams(), size.width, size.height, x, y);\n        // minW should be at least 1\n        minW = Math.max(minW, 1);\n        // maxW should be at most (cols - x)\n        maxW = Math.min(maxW, cols - x);\n        // Min/max capping\n        w = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.clamp)(w, minW, maxW);\n        h = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.clamp)(h, minH, maxH);\n        setResizing(handlerName === \"onResizeStop\" ? undefined : size);\n        handler.call(undefined, {\n            i,\n            x: w,\n            y: h,\n            data: { e, node, size }\n        });\n    };\n    const { x, y, z, w, h, isDraggable, isResizable, droppingPosition, useCSSTransforms } = props;\n    const pos = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_5__.calcGridItemPosition)(getPositionParams(), x, y, z, w, h, {\n        dragging,\n        resizing\n    });\n    const child = react__WEBPACK_IMPORTED_MODULE_1__.Children.only(props.children);\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(child, {\n        ref: elementRef,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"react-grid-item\", child.props.className, props.className, {\n            static: props.static,\n            resizing: Boolean(resizing),\n            \"react-draggable\": isDraggable,\n            \"react-draggable-dragging\": Boolean(dragging),\n            dropping: Boolean(droppingPosition),\n            cssTransforms: useCSSTransforms\n        }),\n        // We can set the width and height on the child, but unfortunately we can't set the position.\n        style: {\n            ...props.style,\n            ...child.props.style,\n            ...createStyle(pos)\n        }\n    });\n    // Resizabl e support. This is usually on but the user can toggle it off.\n    newChild = mixinResizable(newChild, pos, isResizable);\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = mixinDraggable(newChild, isDraggable);\n    return newChild;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridItem);\n//# sourceMappingURL=GridItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL0dyaWRJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0E7QUFDQTtBQUNKO0FBQ2E7QUFDNEU7QUFDN0c7QUFDeEI7QUFDQSxvQ0FBb0MsK0NBQVE7QUFDNUMsb0NBQW9DLCtDQUFRO0FBQzVDLHNDQUFzQywrQ0FBUTtBQUM5QyxzQ0FBc0MsK0NBQVE7QUFDOUMsdUJBQXVCLDZDQUFNO0FBQzdCLFVBQVUsa0lBQWtJO0FBQzVJO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRDQUFJO0FBQ2pDLDhCQUE4Qiw0Q0FBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQUksQ0FBQywwREFBYSxJQUFJLHlQQUF5UDtBQUMvUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFB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QixxRUFBb0I7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsMkNBQWM7QUFDaEM7QUFDQSxtQkFBbUIsK0NBQWtCO0FBQ3JDO0FBQ0EsbUJBQW1CLGdEQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsUUFBUSxFQUFDO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL0dyaWRJdGVtLmpzPzU5NjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBEcmFnZ2FibGVDb3JlIH0gZnJvbSBcInJlYWN0LWRyYWdnYWJsZVwiO1xuaW1wb3J0IHsgUmVzaXphYmxlIH0gZnJvbSBcInJlYWN0LXJlc2l6YWJsZVwiO1xuaW1wb3J0IHsgcGVyYywgc2V0VG9wTGVmdCwgc2V0VHJhbnNmb3JtIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IGNhbGNHcmlkSXRlbVBvc2l0aW9uLCBjYWxjR3JpZEl0ZW1XSFB4LCBjYWxjR3JpZENvbFdpZHRoLCBjYWxjWFksIGNhbGNXSCwgY2xhbXAsIHJlc29sdmVSb3dIZWlnaHQgfSBmcm9tIFwiLi9jYWxjdWxhdGVVdGlsc1wiO1xuaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmNvbnN0IEdyaWRJdGVtID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgW3Jlc2l6aW5nLCBzZXRSZXNpemluZ10gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoKTtcbiAgICBjb25zdCBbZHJhZ1N0YXJ0LCBzZXREcmFnU3RhcnRdID0gdXNlU3RhdGUoKTtcbiAgICBjb25zdCBbY2xhc3NOYW1lLCBzZXRDbGFzc05hbWVdID0gdXNlU3RhdGUocHJvcHMuY2xhc3NOYW1lIHx8IFwiXCIpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYoKTtcbiAgICBsZXQgeyBjYW5jZWwgPSBcIlwiLCBoYW5kbGUgPSBcIlwiLCBtaW5IID0gMSwgbWluVyA9IDEsIG1heEggPSBJbmZpbml0eSwgbWF4VyA9IEluZmluaXR5LCB0cmFuc2Zvcm1TY2FsZSA9IDEsIHJlc2l6ZUhhbmRsZXMsIHJlc2l6ZUhhbmRsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgbW92ZURyb3BwaW5nSXRlbSA9IChwcmV2UHJvcHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkcm9wcGluZ1Bvc2l0aW9uIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkcm9wcGluZ1Bvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICAvLyBDYW4ndCBmaW5kIERPTSBub2RlIChhcmUgd2UgdW5tb3VudGVkPylcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcmV2RHJvcHBpbmdQb3NpdGlvbiA9IHByZXZQcm9wcy5kcm9wcGluZ1Bvc2l0aW9uIHx8IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvdWxkRHJhZyA9IChkcmFnZ2luZyAmJiBkcm9wcGluZ1Bvc2l0aW9uLmxlZnQgIT09IHByZXZEcm9wcGluZ1Bvc2l0aW9uLmxlZnQpIHx8XG4gICAgICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uLnRvcCAhPT0gcHJldkRyb3BwaW5nUG9zaXRpb24udG9wO1xuICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICBvbkRyYWdTdGFydChkcm9wcGluZ1Bvc2l0aW9uLmUsIHtcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGRlbHRhWDogZHJvcHBpbmdQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIGRlbHRhWTogZHJvcHBpbmdQb3NpdGlvbi50b3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNob3VsZERyYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IGRyb3BwaW5nUG9zaXRpb24ubGVmdCAtIGRyYWdnaW5nLmxlZnQ7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBkcm9wcGluZ1Bvc2l0aW9uLnRvcCAtIGRyYWdnaW5nLnRvcDtcbiAgICAgICAgICAgIG9uRHJhZyhkcm9wcGluZ1Bvc2l0aW9uLmUsIHtcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgICAgICBkZWx0YVlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUT0RPXG4gICAgLy8gc2V0RWZmZWN0KChtb3ZlRHJvcHBpbmdJdGVtKCkpPT5bZHJvcHBpbmdQb3NpdGlvbl0pXG4gICAgY29uc3QgZ2V0UG9zaXRpb25QYXJhbXMgPSAocCA9IHByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xzOiBwLmNvbHMsXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nOiBwLmNvbnRhaW5lclBhZGRpbmcsXG4gICAgICAgICAgICBjb250YWluZXJXaWR0aDogcC5jb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgIG1hcmdpbjogcC5tYXJnaW4sXG4gICAgICAgICAgICBtYXhSb3dzOiBwLm1heFJvd3MsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IHAucm93SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHdoZXJlIHdlIHNldCB0aGUgZ3JpZCBpdGVtJ3MgYWJzb2x1dGUgcGxhY2VtZW50LiBJdCBnZXRzIGEgbGl0dGxlIHRyaWNreSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gaXRcbiAgICAgKiB3ZWxsIHdoZW4gc2VydmVyIHJlbmRlcmluZywgYW5kIHRoZSBvbmx5IHdheSB0byBkbyB0aGF0IHByb3Blcmx5IGlzIHRvIHVzZSBwZXJjZW50YWdlIHdpZHRoL2xlZnQgYmVjYXVzZVxuICAgICAqIHdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IHRoZSBicm93c2VyIHZpZXdwb3J0IGlzLlxuICAgICAqIFVuZm9ydHVuYXRlbHksIENTUyBUcmFuc2Zvcm1zLCB3aGljaCBhcmUgZ3JlYXQgZm9yIHBlcmZvcm1hbmNlLCBicmVhayBpbiB0aGlzIGluc3RhbmNlIGJlY2F1c2UgYSBwZXJjZW50YWdlXG4gICAgICogbGVmdCBpcyByZWxhdGl2ZSB0byB0aGUgaXRlbSBpdHNlbGYsIG5vdCBpdHMgY29udGFpbmVyISBTbyB3ZSBjYW5ub3QgdXNlIHRoZW0gb24gdGhlIHNlcnZlciByZW5kZXJpbmcgcGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcG9zIFBvc2l0aW9uIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBTdHlsZSBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlU3R5bGUgPSAocG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlUGVyY2VudGFnZXMsIGNvbnRhaW5lcldpZHRoLCB1c2VDU1NUcmFuc2Zvcm1zIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHN0eWxlO1xuICAgICAgICAvLyBDU1MgVHJhbnNmb3JtcyBzdXBwb3J0IChkZWZhdWx0KVxuICAgICAgICBpZiAodXNlQ1NTVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgc3R5bGUgPSBzZXRUcmFuc2Zvcm0ocG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvcCxsZWZ0IChzbG93KVxuICAgICAgICAgICAgc3R5bGUgPSBzZXRUb3BMZWZ0KHBvcyk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICAgICAgICBpZiAodXNlUGVyY2VudGFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgd2lkdGggaXMgbWlzc2luZyFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBwZXJjKHBvcy5sZWZ0IC8gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gcGVyYyhwb3Mud2lkdGggLyBjb250YWluZXJXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWl4IGEgRHJhZ2dhYmxlIGluc3RhbmNlIGludG8gYSBjaGlsZC5cbiAgICAgKiBAcGFyYW0gIHtFbGVtZW50fSBjaGlsZCAgICBDaGlsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICAgICAgIENoaWxkIHdyYXBwZWQgaW4gRHJhZ2dhYmxlLlxuICAgICAqL1xuICAgIGNvbnN0IG1peGluRHJhZ2dhYmxlID0gKGNoaWxkLCBpc0RyYWdnYWJsZSkgPT4ge1xuICAgICAgICByZXR1cm4gKF9qc3goRHJhZ2dhYmxlQ29yZSwgeyBkaXNhYmxlZDogIWlzRHJhZ2dhYmxlLCBvblN0YXJ0OiBvbkRyYWdTdGFydCwgb25EcmFnOiBvbkRyYWcsIG9uU3RvcDogb25EcmFnU3RvcCwgaGFuZGxlOiBwcm9wcy5oYW5kbGUsIGNhbmNlbDogXCIucmVhY3QtcmVzaXphYmxlLWhhbmRsZVwiICsgKHByb3BzLmNhbmNlbCA/IFwiLFwiICsgcHJvcHMuY2FuY2VsIDogXCJcIiksIHNjYWxlOiBwcm9wcy50cmFuc2Zvcm1TY2FsZSwgbm9kZVJlZjogZWxlbWVudFJlZiwgY2hpbGRyZW46IGNoaWxkIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1peCBhIFJlc2l6YWJsZSBpbnN0YW5jZSBpbnRvIGEgY2hpbGQuXG4gICAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICAgQ2hpbGQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvc2l0aW9uICBQb3NpdGlvbiBvYmplY3QgKHBpeGVsIHZhbHVlcylcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgICAgICBDaGlsZCB3cmFwcGVkIGluIFJlc2l6YWJsZS5cbiAgICAgKi9cbiAgICBjb25zdCBtaXhpblJlc2l6YWJsZSA9IChjaGlsZCwgcG9zaXRpb24sIGlzUmVzaXphYmxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUGFyYW1zID0gZ2V0UG9zaXRpb25QYXJhbXMoKTtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWF4IHBvc3NpYmxlIHdpZHRoIC0gZG9lc24ndCBnbyB0byBpbmZpbml0eSBiZWNhdXNlIG9mIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gY2FsY0dyaWRJdGVtUG9zaXRpb24ocG9zaXRpb25QYXJhbXMsIDAsIDAsIDAsIHByb3BzLmNvbHMgLSBwcm9wcy54LCAvLyBUT0RPIHR5cGVzXG4gICAgICAgIDApLndpZHRoO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbWluL21heCBjb25zdHJhaW50cyB1c2luZyBvdXIgbWluICYgbWF4ZXNcbiAgICAgICAgY29uc3QgbWlucyA9IGNhbGNHcmlkSXRlbVBvc2l0aW9uKHBvc2l0aW9uUGFyYW1zLCAwLCAwLCAwLCBtaW5XLCBtaW5IKTtcbiAgICAgICAgY29uc3QgbWF4ZXMgPSBjYWxjR3JpZEl0ZW1Qb3NpdGlvbihwb3NpdGlvblBhcmFtcywgMCwgMCwgMCwgbWF4VywgbWF4SCk7XG4gICAgICAgIGNvbnN0IG1pbkNvbnN0cmFpbnRzID0gW21pbnMud2lkdGgsIG1pbnMuaGVpZ2h0XTtcbiAgICAgICAgY29uc3QgbWF4Q29uc3RyYWludHMgPSBbXG4gICAgICAgICAgICBNYXRoLm1pbihtYXhlcy53aWR0aCwgbWF4V2lkdGgpLFxuICAgICAgICAgICAgTWF0aC5taW4obWF4ZXMuaGVpZ2h0LCBJbmZpbml0eSlcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChfanN4KFJlc2l6YWJsZVxuICAgICAgICAvLyBUaGVzZSBhcmUgb3B0cyBmb3IgdGhlIHJlc2l6ZSBoYW5kbGUgaXRzZWxmXG4gICAgICAgICwgeyBcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBvcHRzIGZvciB0aGUgcmVzaXplIGhhbmRsZSBpdHNlbGZcbiAgICAgICAgICAgIGRyYWdnYWJsZU9wdHM6IHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogIWlzUmVzaXphYmxlXG4gICAgICAgICAgICB9LCBjbGFzc05hbWU6IGlzUmVzaXphYmxlID8gdW5kZWZpbmVkIDogXCJyZWFjdC1yZXNpemFibGUtaGlkZVwiLCB3aWR0aDogcG9zaXRpb24ud2lkdGgsIGhlaWdodDogcG9zaXRpb24uaGVpZ2h0LCBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsIG1heENvbnN0cmFpbnRzOiBtYXhDb25zdHJhaW50cywgb25SZXNpemVTdG9wOiBvblJlc2l6ZVN0b3AsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIG9uUmVzaXplOiBvblJlc2l6ZSwgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLCByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzLCBoYW5kbGU6IHJlc2l6ZUhhbmRsZSwgY2hpbGRyZW46IGNoaWxkIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9uRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBjb25zdCBvbkRyYWdTdGFydCA9IChlLCB7IG5vZGUgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFvbkRyYWdTdGFydClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICAvLyBUT0RPOiB0aGlzIHdvbnQgd29yayBvbiBuZXN0ZWQgcGFyZW50c1xuICAgICAgICBjb25zdCB7IG9mZnNldFBhcmVudCB9ID0gbm9kZTtcbiAgICAgICAgaWYgKCFvZmZzZXRQYXJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBjTGVmdCA9IGNsaWVudFJlY3QubGVmdCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgICBjb25zdCBwTGVmdCA9IHBhcmVudFJlY3QubGVmdCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgICBjb25zdCBjVG9wID0gY2xpZW50UmVjdC50b3AgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgICAgY29uc3QgcFRvcCA9IHBhcmVudFJlY3QudG9wIC8gdHJhbnNmb3JtU2NhbGU7XG4gICAgICAgIG5ld1Bvc2l0aW9uLmxlZnQgPSBjTGVmdCAtIHBMZWZ0ICsgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIG5ld1Bvc2l0aW9uLnRvcCA9IGNUb3AgLSBwVG9wICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgc2V0RHJhZ2dpbmcobmV3UG9zaXRpb24pO1xuICAgICAgICAvLyBDYWxsIGNhbGxiYWNrIHdpdGggdGhpcyBkYXRhXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gY2FsY1hZKGdldFBvc2l0aW9uUGFyYW1zKCksIG5ld1Bvc2l0aW9uLnRvcCwgbmV3UG9zaXRpb24ubGVmdCwgcHJvcHMudywgLy8gVE9ETyB0eXBlc1xuICAgICAgICBwcm9wcy5oIC8vIFRPRE8gdHlwZXNcbiAgICAgICAgKTtcbiAgICAgICAgc2V0RHJhZ1N0YXJ0KHsgeCwgeSB9KTtcbiAgICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0LmNhbGwodGhpcywge1xuICAgICAgICAgICAgaTogcHJvcHMuaSxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBuZXdQb3NpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9uRHJhZyBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlICAgICAgICAgICAgIGV2ZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNhbGxiYWNrRGF0YSAgYW4gb2JqZWN0IHdpdGggbm9kZSwgZGVsdGEgYW5kIHBvc2l0aW9uIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY29uc3Qgb25EcmFnID0gKGUsIHsgbm9kZSwgZGVsdGFYLCBkZWx0YVkgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uRHJhZyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghb25EcmFnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkRyYWcgY2FsbGVkIGJlZm9yZSBvbkRyYWdTdGFydC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvcCA9IGRyYWdnaW5nLnRvcCArIGRlbHRhWTtcbiAgICAgICAgbGV0IGxlZnQgPSBkcmFnZ2luZy5sZWZ0ICsgZGVsdGFYO1xuICAgICAgICBjb25zdCB7IGlzQm91bmRlZCwgaSwgdywgaCwgY29udGFpbmVyV2lkdGggfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBwb3NpdGlvblBhcmFtcyA9IGdldFBvc2l0aW9uUGFyYW1zKCk7XG4gICAgICAgIC8vIEJvdW5kYXJ5IGNhbGN1bGF0aW9uczsga2VlcHMgaXRlbXMgd2l0aGluIHRoZSBncmlkXG4gICAgICAgIGlmIChpc0JvdW5kZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0UGFyZW50IH0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWFyZ2luLCByb3dIZWlnaHQgfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0hlaWdodE51bWJlciA9IHJlc29sdmVSb3dIZWlnaHQocm93SGVpZ2h0LCBjb2xXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tQm91bmRhcnkgPSBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgY2FsY0dyaWRJdGVtV0hQeChoLCByb3dIZWlnaHROdW1iZXIsIG1hcmdpblsxXSk7XG4gICAgICAgICAgICAgICAgdG9wID0gY2xhbXAodG9wLCAwLCBib3R0b21Cb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IGNvbnRhaW5lcldpZHRoIC0gY2FsY0dyaWRJdGVtV0hQeCh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY2xhbXAobGVmdCwgMCwgcmlnaHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB7IHRvcCwgbGVmdCB9O1xuICAgICAgICBzZXREcmFnZ2luZyhuZXdQb3NpdGlvbik7XG4gICAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBjYWxjWFkocG9zaXRpb25QYXJhbXMsIHRvcCwgbGVmdCwgdywgaCk7XG4gICAgICAgIHJldHVybiBvbkRyYWcuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogb25EcmFnU3RvcCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlICAgICAgICAgICAgIGV2ZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNhbGxiYWNrRGF0YSAgYW4gb2JqZWN0IHdpdGggbm9kZSwgZGVsdGEgYW5kIHBvc2l0aW9uIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY29uc3Qgb25EcmFnU3RvcCA9IChlLCB7IG5vZGUgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uRHJhZ1N0b3AgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIW9uRHJhZ1N0b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRHJhZ0VuZCBjYWxsZWQgYmVmb3JlIG9uRHJhZ1N0YXJ0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHcsIGgsIGkgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gZHJhZ2dpbmc7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0geyB0b3AsIGxlZnQgfTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBjYWxjWFkoZ2V0UG9zaXRpb25QYXJhbXMoKSwgdG9wLCBsZWZ0LCB3LCBoKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IGRyYWdTdGFydD8ueCAhPT0geCB8fCBkcmFnU3RhcnQ/LnkgIT09IHk7XG4gICAgICAgIHNldERyYWdnaW5nKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldERyYWdTdGFydCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb25EcmFnU3RvcC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgbmV3UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY2hhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogb25SZXNpemVTdG9wIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlIGFuZCBzaXplIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY29uc3Qgb25SZXNpemVTdG9wID0gKGUsIGNhbGxiYWNrRGF0YSkgPT4ge1xuICAgICAgICBvblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBcIm9uUmVzaXplU3RvcFwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9uUmVzaXplU3RhcnQgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUgYW5kIHNpemUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBjb25zdCBvblJlc2l6ZVN0YXJ0ID0gKGUsIGNhbGxiYWNrRGF0YSkgPT4ge1xuICAgICAgICBvblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBcIm9uUmVzaXplU3RhcnRcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvblJlc2l6ZSBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlICAgICAgICAgICAgIGV2ZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNhbGxiYWNrRGF0YSAgYW4gb2JqZWN0IHdpdGggbm9kZSBhbmQgc2l6ZSBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNvbnN0IG9uUmVzaXplID0gKGUsIGNhbGxiYWNrRGF0YSkgPT4ge1xuICAgICAgICBvblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBcIm9uUmVzaXplXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBhcm91bmQgZHJhZyBldmVudHMgdG8gcHJvdmlkZSBtb3JlIHVzZWZ1bCBkYXRhLlxuICAgICAqIEFsbCBkcmFnIGV2ZW50cyBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBoYW5kbGVyIG5hbWUsXG4gICAgICogd2l0aCB0aGUgc2lnbmF0dXJlIChpbmRleCwgeCwgeSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGhhbmRsZXJOYW1lIEhhbmRsZXIgbmFtZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgSGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBvblJlc2l6ZUhhbmRsZXIgPSAoZSwgeyBub2RlLCBzaXplIH0sIGhhbmRsZXJOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZV07XG4gICAgICAgIGlmICghaGFuZGxlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBjb2xzLCB4LCB5LCBpIH0gPSBwcm9wcztcbiAgICAgICAgLy8gR2V0IG5ldyBYWVxuICAgICAgICBsZXQgeyB3LCBoIH0gPSBjYWxjV0goZ2V0UG9zaXRpb25QYXJhbXMoKSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHgsIHkpO1xuICAgICAgICAvLyBtaW5XIHNob3VsZCBiZSBhdCBsZWFzdCAxXG4gICAgICAgIG1pblcgPSBNYXRoLm1heChtaW5XLCAxKTtcbiAgICAgICAgLy8gbWF4VyBzaG91bGQgYmUgYXQgbW9zdCAoY29scyAtIHgpXG4gICAgICAgIG1heFcgPSBNYXRoLm1pbihtYXhXLCBjb2xzIC0geCk7XG4gICAgICAgIC8vIE1pbi9tYXggY2FwcGluZ1xuICAgICAgICB3ID0gY2xhbXAodywgbWluVywgbWF4Vyk7XG4gICAgICAgIGggPSBjbGFtcChoLCBtaW5ILCBtYXhIKTtcbiAgICAgICAgc2V0UmVzaXppbmcoaGFuZGxlck5hbWUgPT09IFwib25SZXNpemVTdG9wXCIgPyB1bmRlZmluZWQgOiBzaXplKTtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB4OiB3LFxuICAgICAgICAgICAgeTogaCxcbiAgICAgICAgICAgIGRhdGE6IHsgZSwgbm9kZSwgc2l6ZSB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgeyB4LCB5LCB6LCB3LCBoLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUsIGRyb3BwaW5nUG9zaXRpb24sIHVzZUNTU1RyYW5zZm9ybXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcyA9IGNhbGNHcmlkSXRlbVBvc2l0aW9uKGdldFBvc2l0aW9uUGFyYW1zKCksIHgsIHksIHosIHcsIGgsIHtcbiAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgIHJlc2l6aW5nXG4gICAgfSk7XG4gICAgY29uc3QgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KHByb3BzLmNoaWxkcmVuKTtcbiAgICAvLyBDcmVhdGUgdGhlIGNoaWxkIGVsZW1lbnQuIFdlIGNsb25lIHRoZSBleGlzdGluZyBlbGVtZW50IGJ1dCBtb2RpZnkgaXRzIGNsYXNzTmFtZSBhbmQgc3R5bGUuXG4gICAgbGV0IG5ld0NoaWxkID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIHJlZjogZWxlbWVudFJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtZ3JpZC1pdGVtXCIsIGNoaWxkLnByb3BzLmNsYXNzTmFtZSwgcHJvcHMuY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICBzdGF0aWM6IHByb3BzLnN0YXRpYyxcbiAgICAgICAgICAgIHJlc2l6aW5nOiBCb29sZWFuKHJlc2l6aW5nKSxcbiAgICAgICAgICAgIFwicmVhY3QtZHJhZ2dhYmxlXCI6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgXCJyZWFjdC1kcmFnZ2FibGUtZHJhZ2dpbmdcIjogQm9vbGVhbihkcmFnZ2luZyksXG4gICAgICAgICAgICBkcm9wcGluZzogQm9vbGVhbihkcm9wcGluZ1Bvc2l0aW9uKSxcbiAgICAgICAgICAgIGNzc1RyYW5zZm9ybXM6IHVzZUNTU1RyYW5zZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFdlIGNhbiBzZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIGNoaWxkLCBidXQgdW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBzZXQgdGhlIHBvc2l0aW9uLlxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAuLi5jaGlsZC5wcm9wcy5zdHlsZSxcbiAgICAgICAgICAgIC4uLmNyZWF0ZVN0eWxlKHBvcylcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFJlc2l6YWJsIGUgc3VwcG9ydC4gVGhpcyBpcyB1c3VhbGx5IG9uIGJ1dCB0aGUgdXNlciBjYW4gdG9nZ2xlIGl0IG9mZi5cbiAgICBuZXdDaGlsZCA9IG1peGluUmVzaXphYmxlKG5ld0NoaWxkLCBwb3MsIGlzUmVzaXphYmxlKTtcbiAgICAvLyBEcmFnZ2FibGUgc3VwcG9ydC4gVGhpcyBpcyBhbHdheXMgb24sIGV4Y2VwdCBmb3Igd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgbmV3Q2hpbGQgPSBtaXhpbkRyYWdnYWJsZShuZXdDaGlsZCwgaXNEcmFnZ2FibGUpO1xuICAgIHJldHVybiBuZXdDaGlsZDtcbn07XG5leHBvcnQgZGVmYXVsdCBHcmlkSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWRJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridLayout.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/GridLayout.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* binding */ GridLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var fast_equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\");\n/* harmony import */ var _calculateUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js\");\n/* harmony import */ var _GridItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GridItem */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridItem.js\");\n\n\n\n\n\n\n\n\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n    isFirefox = /firefox/i.test(navigator.userAgent);\n}\ncatch (e) {\n    /* Ignore */\n}\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\nconst GridLayout = (properties) => {\n    const { autoSize = true, cols = 12, className = \"\", style = {}, draggableHandle = \"\", draggableCancel = \"\", containerPadding = undefined, rowHeight = 150, maxRows = Infinity, // infinite vertical growth\n    margin = [10, 10], isBounded = false, isDraggable = true, isResizable = true, allowOverlap = false, isDroppable = false, useCSSTransforms = true, transformScale = 1, compactType = \"vertical\", preventCollision = false, droppingItem = {\n        i: \"__dropping-elem__\",\n        h: 1,\n        w: 1\n    }, // TODO fix\n    resizeHandles = [\"se\"], onLayoutChange = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDragStart = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDrag = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDragStop = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onResizeStart = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onResize = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onResizeStop = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDrop = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDropDragOver = _utils__WEBPACK_IMPORTED_MODULE_3__.noop, width = 0, resizeHandle, innerRef } = properties;\n    // Refactored to another module to make way for preval\n    const [activeDrag, setActiveDrag] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [oldDragItem, setOldDragItem] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [oldLayout, setOldLayout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [oldResizeItem, setOldresizeItem] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [droppingDOMNode, setDroppingDOMNode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [droppingPosition, setdDroppingPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [children, setChildren] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(properties.children);\n    const [layout, setLayout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => (0,_utils__WEBPACK_IMPORTED_MODULE_3__.synchronizeLayoutWithChildren)(properties.layout || [], children, cols, compactType, allowOverlap));\n    /*     const [compactTypeState, setCompactTypeState] = useState<CompactType>()\n                      const [propsLayout, setPropsLayout] = useState<Layout>() */\n    const dragEnterCounter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        setMounted(true);\n        // Possibly call back with layout on mount. This should be done after correcting the layout width\n        // to ensure we don't rerender with the wrong width.\n        onLayoutMaybeChanged(layout, layout);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (properties.layout && !Array.isArray(properties.layout)) {\n            console.error(\"Expecting layout to be an Array but got: \", properties.layout);\n        }\n        setLayout((0,_utils__WEBPACK_IMPORTED_MODULE_3__.synchronizeLayoutWithChildren)(properties.layout || [], children, cols, compactType, allowOverlap));\n    }, [JSON.stringify(properties.layout)]);\n    /*   componentDidUpdate(prevProps: Props, prevState: State) {\n                        if (!this.state.activeDrag) {\n                            const newLayout = this.state.layout;\n                            const oldLayout = prevState.layout;\n                \n                            this.onLayoutMaybeChanged(newLayout, oldLayout);\n                        }\n                    } */\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const newLayout = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.synchronizeLayoutWithChildren)(properties.layout || layout, properties.children, properties.cols || cols, properties.compactType, properties.allowOverlap);\n        setLayout(newLayout);\n        setChildren(properties.children);\n    }, [properties.children]);\n    /**\n     * Calculates a pixel value for the container.\n     * @return {String} Container height in pixels.\n     */\n    const containerHeight = () => {\n        if (!autoSize)\n            return;\n        const nbRow = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.bottom)(layout);\n        const containerPaddingY = containerPadding\n            ? containerPadding[1]\n            : margin[1];\n        return (nbRow *\n            (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_4__.resolveRowHeight)(rowHeight, (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcGridColWidth)(getPositionParams())) +\n            (nbRow - 1) * margin[1] +\n            containerPaddingY * 2 +\n            \"px\");\n    };\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    const onDragStartFn = properties => {\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, properties.i);\n        if (!l)\n            return;\n        setOldDragItem((0,_utils__WEBPACK_IMPORTED_MODULE_3__.cloneLayoutItem)(l));\n        setOldLayout(layout);\n        return onDragStart({\n            layout,\n            prev: l,\n            item: l,\n            placeholder: undefined,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n    };\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    const onDragFn = properties => {\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, properties.i);\n        if (!l)\n            return;\n        // Create placeholder (display only)\n        const placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            z: l.z,\n            placeholder: true,\n            i: properties.i\n        };\n        // Move the element to the dragged location.\n        const isUserAction = true;\n        let newLayout = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.moveElement)({\n            layout,\n            l,\n            x: properties.x,\n            y: properties.y,\n            isUserAction,\n            preventCollision,\n            compactType,\n            cols,\n            allowOverlap\n        });\n        onDrag({\n            layout: newLayout,\n            prev: oldDragItem,\n            item: l,\n            placeholder,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n        setLayout(allowOverlap ? newLayout : (0,_utils__WEBPACK_IMPORTED_MODULE_3__.compact)(newLayout, compactType, cols));\n        setActiveDrag(placeholder);\n    };\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    const onDragStopFn = properties => {\n        if (!activeDrag)\n            return;\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, properties.i);\n        if (!l)\n            return;\n        // Move the element here\n        const isUserAction = true;\n        const movedLayout = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.moveElement)({\n            layout,\n            l,\n            x: properties.x,\n            y: properties.y,\n            isUserAction,\n            preventCollision,\n            compactType,\n            cols,\n            allowOverlap\n        });\n        if (properties.data.change) {\n        }\n        onDragStop({\n            layout: movedLayout,\n            prev: oldDragItem,\n            item: l,\n            placeholder: undefined,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n        // Set state\n        const newLayout = allowOverlap\n            ? movedLayout\n            : (0,_utils__WEBPACK_IMPORTED_MODULE_3__.compact)(movedLayout, compactType, cols);\n        setActiveDrag(undefined);\n        setLayout(newLayout);\n        setOldDragItem(undefined);\n        setOldLayout(undefined);\n        if (properties.data.change) {\n            onLayoutChange(newLayout);\n        }\n    };\n    const onLayoutMaybeChanged = (newLayout, oldLayout) => {\n        if (!oldLayout) {\n            oldLayout = layout;\n        }\n        if (!(0,fast_equals__WEBPACK_IMPORTED_MODULE_6__.deepEqual)(oldLayout, newLayout)) {\n            onLayoutChange(newLayout);\n        }\n    };\n    const onResizeStartFn = properties => {\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, properties.i);\n        if (!l)\n            return;\n        setOldresizeItem((0,_utils__WEBPACK_IMPORTED_MODULE_3__.cloneLayoutItem)(l));\n        setOldLayout(layout);\n        onResizeStart({\n            layout,\n            prev: l,\n            item: l,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n    };\n    const onResizeFn = properties => {\n        const [newLayout, l] = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.withLayoutItem)(layout, properties.i, l => {\n            // Something like quad tree should be used\n            // to find collisions faster\n            let hasCollisions;\n            if (preventCollision && !allowOverlap) {\n                const collisions = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getAllCollisions)(layout, {\n                    ...l,\n                    w: properties.x,\n                    h: properties.y\n                }).filter(layoutItem => layoutItem.i !== l.i);\n                hasCollisions = collisions.length > 0;\n                // If we're colliding, we need adjust the placeholder.\n                if (hasCollisions) {\n                    // adjust w && h to maximum allowed space\n                    let leastX = Infinity, leastY = Infinity;\n                    collisions.forEach(layoutItem => {\n                        if (layoutItem.x > l.x)\n                            leastX = Math.min(leastX, layoutItem.x);\n                        if (layoutItem.y > l.y)\n                            leastY = Math.min(leastY, layoutItem.y);\n                    });\n                    if (Number.isFinite(leastX))\n                        l.w = leastX - l.x;\n                    if (Number.isFinite(leastY))\n                        l.h = leastY - l.y;\n                }\n            }\n            if (!hasCollisions) {\n                // Set new width and height.\n                l.w = properties.x;\n                l.h = properties.y;\n            }\n            return l;\n        });\n        // Shouldn't ever happen, but typechecking makes it necessary\n        if (!l)\n            return;\n        // Create placeholder element (display only)\n        const placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            z: l.z,\n            static: true,\n            i: properties.i\n        };\n        onResize({\n            layout: newLayout,\n            prev: oldResizeItem,\n            item: l,\n            placeholder,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n        // Re-compact the newLayout and set the drag placeholder.\n        setLayout(allowOverlap ? newLayout : (0,_utils__WEBPACK_IMPORTED_MODULE_3__.compact)(newLayout, compactType, cols));\n        setActiveDrag(placeholder);\n    };\n    const onResizeStopFn = properties => {\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, properties.i);\n        onResizeStop({\n            layout,\n            prev: oldResizeItem,\n            item: l,\n            event: properties.data.e,\n            node: properties.data.node\n        });\n        // Set state\n        const newLayout = allowOverlap\n            ? layout\n            : (0,_utils__WEBPACK_IMPORTED_MODULE_3__.compact)(layout, compactType, cols);\n        setActiveDrag(undefined);\n        setLayout(newLayout);\n        setOldresizeItem(undefined);\n        setOldLayout(undefined);\n        onLayoutMaybeChanged(newLayout, oldLayout);\n    };\n    /**\n     * Create a placeholder object.\n     * @return {Element} Placeholder div.\n     */\n    const placeholder = () => {\n        if (!activeDrag)\n            return;\n        // {...activeDrag} is pretty slow, actually\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_GridItem__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { w: activeDrag.w, h: activeDrag.h, x: activeDrag.x, y: activeDrag.y, z: activeDrag.z || 0, i: activeDrag.i, className: \"react-grid-placeholder\", containerWidth: width, cols: cols, margin: margin, containerPadding: containerPadding || margin, maxRows: maxRows, rowHeight: rowHeight, isDraggable: false, isResizable: false, isBounded: false, useCSSTransforms: useCSSTransforms, transformScale: transformScale, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {}) }));\n    };\n    /**\n     * Given a grid item, set its style attributes & surround in a <Draggable>.\n     * @param  {Element} child React element.\n     * @return {Element}       Element wrapped in draggable and properly placed.\n     */\n    const processGridItem = (child, isDroppingItem) => {\n        if (!child || !child.key)\n            return;\n        const l = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.getLayoutItem)(layout, String(child.key));\n        if (!l)\n            return;\n        // Determine user manipulations possible.\n        // If an item is static, it can't be manipulated by default.\n        // Any properties defined directly on the grid item will take precedence.\n        const draggable = typeof l.isDraggable === \"boolean\"\n            ? l.isDraggable\n            : !l.static && isDraggable;\n        const resizable = typeof l.isResizable === \"boolean\"\n            ? l.isResizable\n            : !l.static && isResizable;\n        const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n        // isBounded set on child if set on parent, and child is not explicitly false\n        const bounded = draggable && isBounded && l.isBounded !== false;\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_GridItem__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { containerWidth: width, cols: cols, margin: margin, containerPadding: containerPadding || margin, maxRows: maxRows, rowHeight: rowHeight, cancel: draggableCancel, handle: draggableHandle, onDragStop: onDragStopFn, onDragStart: onDragStartFn, onDrag: onDragFn, onResizeStart: onResizeStartFn, onResize: onResizeFn, onResizeStop: onResizeStopFn, isDraggable: draggable, isResizable: resizable, isBounded: bounded, useCSSTransforms: useCSSTransforms && mounted, usePercentages: !mounted, transformScale: transformScale, w: l.w, h: l.h, x: l.x, y: l.y, z: l.z || 0, i: l.i, minH: l.minH, minW: l.minW, maxH: l.maxH, maxW: l.maxW, static: l.static, droppingPosition: isDroppingItem ? droppingPosition : undefined, resizeHandles: resizeHandlesOptions, resizeHandle: resizeHandle, children: child }));\n    };\n    const getPositionParams = () => {\n        return {\n            cols,\n            margin,\n            maxRows,\n            rowHeight,\n            containerWidth: width,\n            containerPadding: containerPadding || margin\n        };\n    };\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    const onDragOverFn = e => {\n        e.preventDefault(); // Prevent any browser native action\n        e.stopPropagation();\n        // we should ignore events from layout's children in Firefox\n        // to avoid unpredictable jumping of a dropping placeholder\n        // FIXME remove this hack\n        if (isFirefox &&\n            // $FlowIgnore can't figure this out\n            !e.nativeEvent.target?.[\"classList\"].contains(layoutClassName)) {\n            return false;\n        }\n        // Allow user to customize the dropping item or short-circuit the drop based on the results\n        // of the `onDragOver(e: Event)` callback.\n        const onDragOverResult = onDropDragOver?.(e); // TODO fix\n        if (onDragOverResult === false) {\n            if (droppingDOMNode) {\n                removeDroppingPlaceholder();\n            }\n            return false;\n        }\n        const finalDroppingItem = { ...droppingItem, ...onDragOverResult };\n        // This is relative to the DOM element that this event fired for.\n        const { layerX, layerY } = e.nativeEvent; // TODO fix\n        const droppingPosition = {\n            left: layerX / transformScale,\n            top: layerY / transformScale,\n            e\n        };\n        if (!droppingDOMNode) {\n            const calculatedPosition = (0,_calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcXY)(getPositionParams(), layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n            setDroppingDOMNode((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {}, finalDroppingItem.i));\n            setdDroppingPosition(droppingPosition);\n            setLayout([\n                ...layout,\n                {\n                    ...finalDroppingItem,\n                    x: calculatedPosition.x,\n                    y: calculatedPosition.y,\n                    static: false,\n                    isDraggable: true\n                }\n            ]);\n        }\n        else if (droppingPosition) {\n            const { left, top } = droppingPosition;\n            const shouldUpdatePosition = left != layerX || top != layerY;\n            if (shouldUpdatePosition) {\n                setdDroppingPosition(droppingPosition);\n            }\n        }\n    };\n    const removeDroppingPlaceholder = () => {\n        const newLayout = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.compact)(layout.filter(l => l.i !== droppingItem.i), compactType, cols, allowOverlap);\n        setLayout(newLayout);\n        setDroppingDOMNode(undefined);\n        setActiveDrag(undefined);\n        setdDroppingPosition(undefined);\n    };\n    const onDragLeaveFn = e => {\n        e.preventDefault(); // Prevent any browser native action\n        e.stopPropagation();\n        dragEnterCounter.current = dragEnterCounter.current - 1;\n        // onDragLeave can be triggered on each layout's child.\n        // But we know that count of dragEnter and dragLeave events\n        // will be balanced after leaving the layout's container\n        // so we can increase and decrease count of dragEnter and\n        // when it'll be equal to 0 we'll remove the placeholder\n        if (dragEnterCounter.current === 0) {\n            removeDroppingPlaceholder();\n        }\n    };\n    const onDragEnterFn = e => {\n        e.preventDefault(); // Prevent any browser native action\n        e.stopPropagation();\n        dragEnterCounter.current += 1;\n    };\n    const onDropFn = e => {\n        e.preventDefault(); // Prevent any browser native action\n        e.stopPropagation();\n        const item = layout.find(l => l.i === droppingItem.i);\n        // reset dragEnter counter on drop\n        dragEnterCounter.current = 0;\n        removeDroppingPlaceholder();\n        onDrop({ layout, item, event: e });\n    };\n    const mergedClassName = (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(layoutClassName, className);\n    const mergedStyle = {\n        height: containerHeight(),\n        ...style\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { ref: innerRef, className: mergedClassName, style: mergedStyle, onDrop: isDroppable ? onDropFn : _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDragLeave: isDroppable ? onDragLeaveFn : _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDragEnter: isDroppable ? onDragEnterFn : _utils__WEBPACK_IMPORTED_MODULE_3__.noop, onDragOver: isDroppable ? onDragOverFn : _utils__WEBPACK_IMPORTED_MODULE_3__.noop, children: [children &&\n                (Array.isArray(children)\n                    ? react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, child => processGridItem(child))\n                    : processGridItem(children)) // TODO fix types\n            , isDroppable && droppingDOMNode && processGridItem(droppingDOMNode, true), placeholder()] }));\n};\nGridLayout.displayName = \"GridLayout\";\n\n//# sourceMappingURL=GridLayout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL0dyaWRMYXlvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDaEM7QUFDcUI7QUFDWjtBQUNoQjtBQUNzSTtBQUNoRjtBQUM1QztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkNBQTZDLHdDQUFJLGdCQUFnQix3Q0FBSSxXQUFXLHdDQUFJLGVBQWUsd0NBQUksa0JBQWtCLHdDQUFJLGFBQWEsd0NBQUksaUJBQWlCLHdDQUFJLFdBQVcsd0NBQUksbUJBQW1CLHdDQUFJLHNDQUFzQztBQUMvTztBQUNBLHdDQUF3QywrQ0FBUTtBQUNoRCxrQ0FBa0MsK0NBQVE7QUFDMUMsMENBQTBDLCtDQUFRO0FBQ2xELHNDQUFzQywrQ0FBUTtBQUM5Qyw4Q0FBOEMsK0NBQVE7QUFDdEQsa0RBQWtELCtDQUFRO0FBQzFELHFEQUFxRCwrQ0FBUTtBQUM3RCxvQ0FBb0MsK0NBQVE7QUFDNUMsZ0NBQWdDLCtDQUFRLE9BQU8scUVBQTZCO0FBQzVFO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQU07QUFDbkMsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQTZCO0FBQy9DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixJQUFJLGdEQUFTO0FBQ2IsMEJBQTBCLHFFQUE2QjtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBTTtBQUM1QjtB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QUFjO0FBQ3BDO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC1uZXh0L2xpYi9lc20vR3JpZExheW91dC5qcz81OTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSBcImZhc3QtZXF1YWxzXCI7XG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgYm90dG9tLCBjbG9uZUxheW91dEl0ZW0sIGNvbXBhY3QsIGdldEFsbENvbGxpc2lvbnMsIGdldExheW91dEl0ZW0sIG1vdmVFbGVtZW50LCBub29wLCBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbiwgd2l0aExheW91dEl0ZW0gfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgY2FsY0dyaWRDb2xXaWR0aCwgY2FsY1hZLCByZXNvbHZlUm93SGVpZ2h0IH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjtcbmltcG9ydCBHcmlkSXRlbSBmcm9tIFwiLi9HcmlkSXRlbVwiO1xuLy8gRW5kIFR5cGVzXG5jb25zdCBsYXlvdXRDbGFzc05hbWUgPSBcInJlYWN0LWdyaWQtbGF5b3V0XCI7XG5sZXQgaXNGaXJlZm94ID0gZmFsc2U7XG4vLyBUcnkuLi5jYXRjaCB3aWxsIHByb3RlY3QgZnJvbSBuYXZpZ2F0b3Igbm90IGV4aXN0aW5nIChlLmcuIG5vZGUpIG9yIGEgYmFkIGltcGxlbWVudGF0aW9uIG9mIG5hdmlnYXRvclxudHJ5IHtcbiAgICBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5jYXRjaCAoZSkge1xuICAgIC8qIElnbm9yZSAqL1xufVxuLyoqXG4gKiBBIHJlYWN0aXZlLCBmbHVpZCBncmlkIGxheW91dCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlIGNvbXBvbmVudHMuXG4gKi9cbmNvbnN0IEdyaWRMYXlvdXQgPSAocHJvcGVydGllcykgPT4ge1xuICAgIGNvbnN0IHsgYXV0b1NpemUgPSB0cnVlLCBjb2xzID0gMTIsIGNsYXNzTmFtZSA9IFwiXCIsIHN0eWxlID0ge30sIGRyYWdnYWJsZUhhbmRsZSA9IFwiXCIsIGRyYWdnYWJsZUNhbmNlbCA9IFwiXCIsIGNvbnRhaW5lclBhZGRpbmcgPSB1bmRlZmluZWQsIHJvd0hlaWdodCA9IDE1MCwgbWF4Um93cyA9IEluZmluaXR5LCAvLyBpbmZpbml0ZSB2ZXJ0aWNhbCBncm93dGhcbiAgICBtYXJnaW4gPSBbMTAsIDEwXSwgaXNCb3VuZGVkID0gZmFsc2UsIGlzRHJhZ2dhYmxlID0gdHJ1ZSwgaXNSZXNpemFibGUgPSB0cnVlLCBhbGxvd092ZXJsYXAgPSBmYWxzZSwgaXNEcm9wcGFibGUgPSBmYWxzZSwgdXNlQ1NTVHJhbnNmb3JtcyA9IHRydWUsIHRyYW5zZm9ybVNjYWxlID0gMSwgY29tcGFjdFR5cGUgPSBcInZlcnRpY2FsXCIsIHByZXZlbnRDb2xsaXNpb24gPSBmYWxzZSwgZHJvcHBpbmdJdGVtID0ge1xuICAgICAgICBpOiBcIl9fZHJvcHBpbmctZWxlbV9fXCIsXG4gICAgICAgIGg6IDEsXG4gICAgICAgIHc6IDFcbiAgICB9LCAvLyBUT0RPIGZpeFxuICAgIHJlc2l6ZUhhbmRsZXMgPSBbXCJzZVwiXSwgb25MYXlvdXRDaGFuZ2UgPSBub29wLCBvbkRyYWdTdGFydCA9IG5vb3AsIG9uRHJhZyA9IG5vb3AsIG9uRHJhZ1N0b3AgPSBub29wLCBvblJlc2l6ZVN0YXJ0ID0gbm9vcCwgb25SZXNpemUgPSBub29wLCBvblJlc2l6ZVN0b3AgPSBub29wLCBvbkRyb3AgPSBub29wLCBvbkRyb3BEcmFnT3ZlciA9IG5vb3AsIHdpZHRoID0gMCwgcmVzaXplSGFuZGxlLCBpbm5lclJlZiB9ID0gcHJvcGVydGllcztcbiAgICAvLyBSZWZhY3RvcmVkIHRvIGFub3RoZXIgbW9kdWxlIHRvIG1ha2Ugd2F5IGZvciBwcmV2YWxcbiAgICBjb25zdCBbYWN0aXZlRHJhZywgc2V0QWN0aXZlRHJhZ10gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgW29sZERyYWdJdGVtLCBzZXRPbGREcmFnSXRlbV0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtvbGRMYXlvdXQsIHNldE9sZExheW91dF0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtvbGRSZXNpemVJdGVtLCBzZXRPbGRyZXNpemVJdGVtXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2Ryb3BwaW5nRE9NTm9kZSwgc2V0RHJvcHBpbmdET01Ob2RlXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2Ryb3BwaW5nUG9zaXRpb24sIHNldGREcm9wcGluZ1Bvc2l0aW9uXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2NoaWxkcmVuLCBzZXRDaGlsZHJlbl0gPSB1c2VTdGF0ZShwcm9wZXJ0aWVzLmNoaWxkcmVuKTtcbiAgICBjb25zdCBbbGF5b3V0LCBzZXRMYXlvdXRdID0gdXNlU3RhdGUoKCkgPT4gc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4ocHJvcGVydGllcy5sYXlvdXQgfHwgW10sIGNoaWxkcmVuLCBjb2xzLCBjb21wYWN0VHlwZSwgYWxsb3dPdmVybGFwKSk7XG4gICAgLyogICAgIGNvbnN0IFtjb21wYWN0VHlwZVN0YXRlLCBzZXRDb21wYWN0VHlwZVN0YXRlXSA9IHVzZVN0YXRlPENvbXBhY3RUeXBlPigpXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3BzTGF5b3V0LCBzZXRQcm9wc0xheW91dF0gPSB1c2VTdGF0ZTxMYXlvdXQ+KCkgKi9cbiAgICBjb25zdCBkcmFnRW50ZXJDb3VudGVyID0gdXNlUmVmKDApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgICAgIC8vIFBvc3NpYmx5IGNhbGwgYmFjayB3aXRoIGxheW91dCBvbiBtb3VudC4gVGhpcyBzaG91bGQgYmUgZG9uZSBhZnRlciBjb3JyZWN0aW5nIHRoZSBsYXlvdXQgd2lkdGhcbiAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGRvbid0IHJlcmVuZGVyIHdpdGggdGhlIHdyb25nIHdpZHRoLlxuICAgICAgICBvbkxheW91dE1heWJlQ2hhbmdlZChsYXlvdXQsIGxheW91dCk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxheW91dCAmJiAhQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzLmxheW91dCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeHBlY3RpbmcgbGF5b3V0IHRvIGJlIGFuIEFycmF5IGJ1dCBnb3Q6IFwiLCBwcm9wZXJ0aWVzLmxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGF5b3V0KHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKHByb3BlcnRpZXMubGF5b3V0IHx8IFtdLCBjaGlsZHJlbiwgY29scywgY29tcGFjdFR5cGUsIGFsbG93T3ZlcmxhcCkpO1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzLmxheW91dCldKTtcbiAgICAvKiAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzLCBwcmV2U3RhdGU6IFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlRHJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZExheW91dCA9IHByZXZTdGF0ZS5sYXlvdXQ7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKi9cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdMYXlvdXQgPSBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbihwcm9wZXJ0aWVzLmxheW91dCB8fCBsYXlvdXQsIHByb3BlcnRpZXMuY2hpbGRyZW4sIHByb3BlcnRpZXMuY29scyB8fCBjb2xzLCBwcm9wZXJ0aWVzLmNvbXBhY3RUeXBlLCBwcm9wZXJ0aWVzLmFsbG93T3ZlcmxhcCk7XG4gICAgICAgIHNldExheW91dChuZXdMYXlvdXQpO1xuICAgICAgICBzZXRDaGlsZHJlbihwcm9wZXJ0aWVzLmNoaWxkcmVuKTtcbiAgICB9LCBbcHJvcGVydGllcy5jaGlsZHJlbl0pO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYSBwaXhlbCB2YWx1ZSBmb3IgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENvbnRhaW5lciBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhdXRvU2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmJSb3cgPSBib3R0b20obGF5b3V0KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZ1kgPSBjb250YWluZXJQYWRkaW5nXG4gICAgICAgICAgICA/IGNvbnRhaW5lclBhZGRpbmdbMV1cbiAgICAgICAgICAgIDogbWFyZ2luWzFdO1xuICAgICAgICByZXR1cm4gKG5iUm93ICpcbiAgICAgICAgICAgIHJlc29sdmVSb3dIZWlnaHQocm93SGVpZ2h0LCBjYWxjR3JpZENvbFdpZHRoKGdldFBvc2l0aW9uUGFyYW1zKCkpKSArXG4gICAgICAgICAgICAobmJSb3cgLSAxKSAqIG1hcmdpblsxXSArXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nWSAqIDIgK1xuICAgICAgICAgICAgXCJweFwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gZHJhZ2dpbmcgc3RhcnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGkgSWQgb2YgdGhlIGNoaWxkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGN1cnJlbnQgZHJhZ2dpbmcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdCBvbkRyYWdTdGFydEZuID0gcHJvcGVydGllcyA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSBnZXRMYXlvdXRJdGVtKGxheW91dCwgcHJvcGVydGllcy5pKTtcbiAgICAgICAgaWYgKCFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRPbGREcmFnSXRlbShjbG9uZUxheW91dEl0ZW0obCkpO1xuICAgICAgICBzZXRPbGRMYXlvdXQobGF5b3V0KTtcbiAgICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0KHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHByZXY6IGwsXG4gICAgICAgICAgICBpdGVtOiBsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50OiBwcm9wZXJ0aWVzLmRhdGEuZSxcbiAgICAgICAgICAgIG5vZGU6IHByb3BlcnRpZXMuZGF0YS5ub2RlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRWFjaCBkcmFnIG1vdmVtZW50IGNyZWF0ZSBhIG5ldyBkcmFnZWxlbWVudCBhbmQgbW92ZSB0aGUgZWxlbWVudCB0byB0aGUgZHJhZ2dlZCBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpIElkIG9mIHRoZSBjaGlsZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgY29uc3Qgb25EcmFnRm4gPSBwcm9wZXJ0aWVzID0+IHtcbiAgICAgICAgY29uc3QgbCA9IGdldExheW91dEl0ZW0obGF5b3V0LCBwcm9wZXJ0aWVzLmkpO1xuICAgICAgICBpZiAoIWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciAoZGlzcGxheSBvbmx5KVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgIHc6IGwudyxcbiAgICAgICAgICAgIGg6IGwuaCxcbiAgICAgICAgICAgIHg6IGwueCxcbiAgICAgICAgICAgIHk6IGwueSxcbiAgICAgICAgICAgIHo6IGwueixcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgICAgICAgaTogcHJvcGVydGllcy5pXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb24uXG4gICAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBuZXdMYXlvdXQgPSBtb3ZlRWxlbWVudCh7XG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgeDogcHJvcGVydGllcy54LFxuICAgICAgICAgICAgeTogcHJvcGVydGllcy55LFxuICAgICAgICAgICAgaXNVc2VyQWN0aW9uLFxuICAgICAgICAgICAgcHJldmVudENvbGxpc2lvbixcbiAgICAgICAgICAgIGNvbXBhY3RUeXBlLFxuICAgICAgICAgICAgY29scyxcbiAgICAgICAgICAgIGFsbG93T3ZlcmxhcFxuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnKHtcbiAgICAgICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICAgICAgcHJldjogb2xkRHJhZ0l0ZW0sXG4gICAgICAgICAgICBpdGVtOiBsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBldmVudDogcHJvcGVydGllcy5kYXRhLmUsXG4gICAgICAgICAgICBub2RlOiBwcm9wZXJ0aWVzLmRhdGEubm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0TGF5b3V0KGFsbG93T3ZlcmxhcCA/IG5ld0xheW91dCA6IGNvbXBhY3QobmV3TGF5b3V0LCBjb21wYWN0VHlwZSwgY29scykpO1xuICAgICAgICBzZXRBY3RpdmVEcmFnKHBsYWNlaG9sZGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gZHJhZ2dpbmcgc3RvcHMsIGZpZ3VyZSBvdXQgd2hpY2ggcG9zaXRpb24gdGhlIGVsZW1lbnQgaXMgY2xvc2VzdCB0byBhbmQgdXBkYXRlIGl0cyB4IGFuZCB5LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaSBJbmRleCBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGN1cnJlbnQgZHJhZ2dpbmcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdCBvbkRyYWdTdG9wRm4gPSBwcm9wZXJ0aWVzID0+IHtcbiAgICAgICAgaWYgKCFhY3RpdmVEcmFnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsID0gZ2V0TGF5b3V0SXRlbShsYXlvdXQsIHByb3BlcnRpZXMuaSk7XG4gICAgICAgIGlmICghbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCBoZXJlXG4gICAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1vdmVkTGF5b3V0ID0gbW92ZUVsZW1lbnQoe1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHg6IHByb3BlcnRpZXMueCxcbiAgICAgICAgICAgIHk6IHByb3BlcnRpZXMueSxcbiAgICAgICAgICAgIGlzVXNlckFjdGlvbixcbiAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgICAgICBjb21wYWN0VHlwZSxcbiAgICAgICAgICAgIGNvbHMsXG4gICAgICAgICAgICBhbGxvd092ZXJsYXBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRhdGEuY2hhbmdlKSB7XG4gICAgICAgIH1cbiAgICAgICAgb25EcmFnU3RvcCh7XG4gICAgICAgICAgICBsYXlvdXQ6IG1vdmVkTGF5b3V0LFxuICAgICAgICAgICAgcHJldjogb2xkRHJhZ0l0ZW0sXG4gICAgICAgICAgICBpdGVtOiBsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50OiBwcm9wZXJ0aWVzLmRhdGEuZSxcbiAgICAgICAgICAgIG5vZGU6IHByb3BlcnRpZXMuZGF0YS5ub2RlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgc3RhdGVcbiAgICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwXG4gICAgICAgICAgICA/IG1vdmVkTGF5b3V0XG4gICAgICAgICAgICA6IGNvbXBhY3QobW92ZWRMYXlvdXQsIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICAgICAgc2V0QWN0aXZlRHJhZyh1bmRlZmluZWQpO1xuICAgICAgICBzZXRMYXlvdXQobmV3TGF5b3V0KTtcbiAgICAgICAgc2V0T2xkRHJhZ0l0ZW0odW5kZWZpbmVkKTtcbiAgICAgICAgc2V0T2xkTGF5b3V0KHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRhdGEuY2hhbmdlKSB7XG4gICAgICAgICAgICBvbkxheW91dENoYW5nZShuZXdMYXlvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkxheW91dE1heWJlQ2hhbmdlZCA9IChuZXdMYXlvdXQsIG9sZExheW91dCkgPT4ge1xuICAgICAgICBpZiAoIW9sZExheW91dCkge1xuICAgICAgICAgICAgb2xkTGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKG9sZExheW91dCwgbmV3TGF5b3V0KSkge1xuICAgICAgICAgICAgb25MYXlvdXRDaGFuZ2UobmV3TGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25SZXNpemVTdGFydEZuID0gcHJvcGVydGllcyA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSBnZXRMYXlvdXRJdGVtKGxheW91dCwgcHJvcGVydGllcy5pKTtcbiAgICAgICAgaWYgKCFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRPbGRyZXNpemVJdGVtKGNsb25lTGF5b3V0SXRlbShsKSk7XG4gICAgICAgIHNldE9sZExheW91dChsYXlvdXQpO1xuICAgICAgICBvblJlc2l6ZVN0YXJ0KHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHByZXY6IGwsXG4gICAgICAgICAgICBpdGVtOiBsLFxuICAgICAgICAgICAgZXZlbnQ6IHByb3BlcnRpZXMuZGF0YS5lLFxuICAgICAgICAgICAgbm9kZTogcHJvcGVydGllcy5kYXRhLm5vZGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlc2l6ZUZuID0gcHJvcGVydGllcyA9PiB7XG4gICAgICAgIGNvbnN0IFtuZXdMYXlvdXQsIGxdID0gd2l0aExheW91dEl0ZW0obGF5b3V0LCBwcm9wZXJ0aWVzLmksIGwgPT4ge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGxpa2UgcXVhZCB0cmVlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBmaW5kIGNvbGxpc2lvbnMgZmFzdGVyXG4gICAgICAgICAgICBsZXQgaGFzQ29sbGlzaW9ucztcbiAgICAgICAgICAgIGlmIChwcmV2ZW50Q29sbGlzaW9uICYmICFhbGxvd092ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gZ2V0QWxsQ29sbGlzaW9ucyhsYXlvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubCxcbiAgICAgICAgICAgICAgICAgICAgdzogcHJvcGVydGllcy54LFxuICAgICAgICAgICAgICAgICAgICBoOiBwcm9wZXJ0aWVzLnlcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIobGF5b3V0SXRlbSA9PiBsYXlvdXRJdGVtLmkgIT09IGwuaSk7XG4gICAgICAgICAgICAgICAgaGFzQ29sbGlzaW9ucyA9IGNvbGxpc2lvbnMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBjb2xsaWRpbmcsIHdlIG5lZWQgYWRqdXN0IHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdyAmJiBoIHRvIG1heGltdW0gYWxsb3dlZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBsZXQgbGVhc3RYID0gSW5maW5pdHksIGxlYXN0WSA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zLmZvckVhY2gobGF5b3V0SXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0SXRlbS54ID4gbC54KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYXN0WCA9IE1hdGgubWluKGxlYXN0WCwgbGF5b3V0SXRlbS54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRJdGVtLnkgPiBsLnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhc3RZID0gTWF0aC5taW4obGVhc3RZLCBsYXlvdXRJdGVtLnkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsZWFzdFgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbC53ID0gbGVhc3RYIC0gbC54O1xuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGxlYXN0WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsLmggPSBsZWFzdFkgLSBsLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IG5ldyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGwudyA9IHByb3BlcnRpZXMueDtcbiAgICAgICAgICAgICAgICBsLmggPSBwcm9wZXJ0aWVzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNob3VsZG4ndCBldmVyIGhhcHBlbiwgYnV0IHR5cGVjaGVja2luZyBtYWtlcyBpdCBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCAoZGlzcGxheSBvbmx5KVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgIHc6IGwudyxcbiAgICAgICAgICAgIGg6IGwuaCxcbiAgICAgICAgICAgIHg6IGwueCxcbiAgICAgICAgICAgIHk6IGwueSxcbiAgICAgICAgICAgIHo6IGwueixcbiAgICAgICAgICAgIHN0YXRpYzogdHJ1ZSxcbiAgICAgICAgICAgIGk6IHByb3BlcnRpZXMuaVxuICAgICAgICB9O1xuICAgICAgICBvblJlc2l6ZSh7XG4gICAgICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgICAgIHByZXY6IG9sZFJlc2l6ZUl0ZW0sXG4gICAgICAgICAgICBpdGVtOiBsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBldmVudDogcHJvcGVydGllcy5kYXRhLmUsXG4gICAgICAgICAgICBub2RlOiBwcm9wZXJ0aWVzLmRhdGEubm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmUtY29tcGFjdCB0aGUgbmV3TGF5b3V0IGFuZCBzZXQgdGhlIGRyYWcgcGxhY2Vob2xkZXIuXG4gICAgICAgIHNldExheW91dChhbGxvd092ZXJsYXAgPyBuZXdMYXlvdXQgOiBjb21wYWN0KG5ld0xheW91dCwgY29tcGFjdFR5cGUsIGNvbHMpKTtcbiAgICAgICAgc2V0QWN0aXZlRHJhZyhwbGFjZWhvbGRlcik7XG4gICAgfTtcbiAgICBjb25zdCBvblJlc2l6ZVN0b3BGbiA9IHByb3BlcnRpZXMgPT4ge1xuICAgICAgICBjb25zdCBsID0gZ2V0TGF5b3V0SXRlbShsYXlvdXQsIHByb3BlcnRpZXMuaSk7XG4gICAgICAgIG9uUmVzaXplU3RvcCh7XG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBwcmV2OiBvbGRSZXNpemVJdGVtLFxuICAgICAgICAgICAgaXRlbTogbCxcbiAgICAgICAgICAgIGV2ZW50OiBwcm9wZXJ0aWVzLmRhdGEuZSxcbiAgICAgICAgICAgIG5vZGU6IHByb3BlcnRpZXMuZGF0YS5ub2RlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgc3RhdGVcbiAgICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwXG4gICAgICAgICAgICA/IGxheW91dFxuICAgICAgICAgICAgOiBjb21wYWN0KGxheW91dCwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgICAgICBzZXRBY3RpdmVEcmFnKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldExheW91dChuZXdMYXlvdXQpO1xuICAgICAgICBzZXRPbGRyZXNpemVJdGVtKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldE9sZExheW91dCh1bmRlZmluZWQpO1xuICAgICAgICBvbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwbGFjZWhvbGRlciBvYmplY3QuXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gUGxhY2Vob2xkZXIgZGl2LlxuICAgICAqL1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWFjdGl2ZURyYWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHsuLi5hY3RpdmVEcmFnfSBpcyBwcmV0dHkgc2xvdywgYWN0dWFsbHlcbiAgICAgICAgcmV0dXJuIChfanN4KEdyaWRJdGVtLCB7IHc6IGFjdGl2ZURyYWcudywgaDogYWN0aXZlRHJhZy5oLCB4OiBhY3RpdmVEcmFnLngsIHk6IGFjdGl2ZURyYWcueSwgejogYWN0aXZlRHJhZy56IHx8IDAsIGk6IGFjdGl2ZURyYWcuaSwgY2xhc3NOYW1lOiBcInJlYWN0LWdyaWQtcGxhY2Vob2xkZXJcIiwgY29udGFpbmVyV2lkdGg6IHdpZHRoLCBjb2xzOiBjb2xzLCBtYXJnaW46IG1hcmdpbiwgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sIG1heFJvd3M6IG1heFJvd3MsIHJvd0hlaWdodDogcm93SGVpZ2h0LCBpc0RyYWdnYWJsZTogZmFsc2UsIGlzUmVzaXphYmxlOiBmYWxzZSwgaXNCb3VuZGVkOiBmYWxzZSwgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcywgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLCBjaGlsZHJlbjogX2pzeChcImRpdlwiLCB7fSkgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBncmlkIGl0ZW0sIHNldCBpdHMgc3R5bGUgYXR0cmlidXRlcyAmIHN1cnJvdW5kIGluIGEgPERyYWdnYWJsZT4uXG4gICAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgUmVhY3QgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgICBFbGVtZW50IHdyYXBwZWQgaW4gZHJhZ2dhYmxlIGFuZCBwcm9wZXJseSBwbGFjZWQuXG4gICAgICovXG4gICAgY29uc3QgcHJvY2Vzc0dyaWRJdGVtID0gKGNoaWxkLCBpc0Ryb3BwaW5nSXRlbSkgPT4ge1xuICAgICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5rZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGwgPSBnZXRMYXlvdXRJdGVtKGxheW91dCwgU3RyaW5nKGNoaWxkLmtleSkpO1xuICAgICAgICBpZiAoIWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIERldGVybWluZSB1c2VyIG1hbmlwdWxhdGlvbnMgcG9zc2libGUuXG4gICAgICAgIC8vIElmIGFuIGl0ZW0gaXMgc3RhdGljLCBpdCBjYW4ndCBiZSBtYW5pcHVsYXRlZCBieSBkZWZhdWx0LlxuICAgICAgICAvLyBBbnkgcHJvcGVydGllcyBkZWZpbmVkIGRpcmVjdGx5IG9uIHRoZSBncmlkIGl0ZW0gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgICAgIGNvbnN0IGRyYWdnYWJsZSA9IHR5cGVvZiBsLmlzRHJhZ2dhYmxlID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgPyBsLmlzRHJhZ2dhYmxlXG4gICAgICAgICAgICA6ICFsLnN0YXRpYyAmJiBpc0RyYWdnYWJsZTtcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gdHlwZW9mIGwuaXNSZXNpemFibGUgPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICA/IGwuaXNSZXNpemFibGVcbiAgICAgICAgICAgIDogIWwuc3RhdGljICYmIGlzUmVzaXphYmxlO1xuICAgICAgICBjb25zdCByZXNpemVIYW5kbGVzT3B0aW9ucyA9IGwucmVzaXplSGFuZGxlcyB8fCByZXNpemVIYW5kbGVzO1xuICAgICAgICAvLyBpc0JvdW5kZWQgc2V0IG9uIGNoaWxkIGlmIHNldCBvbiBwYXJlbnQsIGFuZCBjaGlsZCBpcyBub3QgZXhwbGljaXRseSBmYWxzZVxuICAgICAgICBjb25zdCBib3VuZGVkID0gZHJhZ2dhYmxlICYmIGlzQm91bmRlZCAmJiBsLmlzQm91bmRlZCAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoX2pzeChHcmlkSXRlbSwgeyBjb250YWluZXJXaWR0aDogd2lkdGgsIGNvbHM6IGNvbHMsIG1hcmdpbjogbWFyZ2luLCBjb250YWluZXJQYWRkaW5nOiBjb250YWluZXJQYWRkaW5nIHx8IG1hcmdpbiwgbWF4Um93czogbWF4Um93cywgcm93SGVpZ2h0OiByb3dIZWlnaHQsIGNhbmNlbDogZHJhZ2dhYmxlQ2FuY2VsLCBoYW5kbGU6IGRyYWdnYWJsZUhhbmRsZSwgb25EcmFnU3RvcDogb25EcmFnU3RvcEZuLCBvbkRyYWdTdGFydDogb25EcmFnU3RhcnRGbiwgb25EcmFnOiBvbkRyYWdGbiwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydEZuLCBvblJlc2l6ZTogb25SZXNpemVGbiwgb25SZXNpemVTdG9wOiBvblJlc2l6ZVN0b3BGbiwgaXNEcmFnZ2FibGU6IGRyYWdnYWJsZSwgaXNSZXNpemFibGU6IHJlc2l6YWJsZSwgaXNCb3VuZGVkOiBib3VuZGVkLCB1c2VDU1NUcmFuc2Zvcm1zOiB1c2VDU1NUcmFuc2Zvcm1zICYmIG1vdW50ZWQsIHVzZVBlcmNlbnRhZ2VzOiAhbW91bnRlZCwgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLCB3OiBsLncsIGg6IGwuaCwgeDogbC54LCB5OiBsLnksIHo6IGwueiB8fCAwLCBpOiBsLmksIG1pbkg6IGwubWluSCwgbWluVzogbC5taW5XLCBtYXhIOiBsLm1heEgsIG1heFc6IGwubWF4Vywgc3RhdGljOiBsLnN0YXRpYywgZHJvcHBpbmdQb3NpdGlvbjogaXNEcm9wcGluZ0l0ZW0gPyBkcm9wcGluZ1Bvc2l0aW9uIDogdW5kZWZpbmVkLCByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzT3B0aW9ucywgcmVzaXplSGFuZGxlOiByZXNpemVIYW5kbGUsIGNoaWxkcmVuOiBjaGlsZCB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQb3NpdGlvblBhcmFtcyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHMsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICBtYXhSb3dzLFxuICAgICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIENhbGxlZCB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50LiBQYXJ0IG9mIGJyb3dzZXIgbmF0aXZlIGRyYWcvZHJvcCBBUEkuXG4gICAgLy8gTmF0aXZlIGV2ZW50IHRhcmdldCBtaWdodCBiZSB0aGUgbGF5b3V0IGl0c2VsZiwgb3IgYW4gZWxlbWVudCB3aXRoaW4gdGhlIGxheW91dC5cbiAgICBjb25zdCBvbkRyYWdPdmVyRm4gPSBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSBldmVudHMgZnJvbSBsYXlvdXQncyBjaGlsZHJlbiBpbiBGaXJlZm94XG4gICAgICAgIC8vIHRvIGF2b2lkIHVucHJlZGljdGFibGUganVtcGluZyBvZiBhIGRyb3BwaW5nIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIEZJWE1FIHJlbW92ZSB0aGlzIGhhY2tcbiAgICAgICAgaWYgKGlzRmlyZWZveCAmJlxuICAgICAgICAgICAgLy8gJEZsb3dJZ25vcmUgY2FuJ3QgZmlndXJlIHRoaXMgb3V0XG4gICAgICAgICAgICAhZS5uYXRpdmVFdmVudC50YXJnZXQ/LltcImNsYXNzTGlzdFwiXS5jb250YWlucyhsYXlvdXRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgdXNlciB0byBjdXN0b21pemUgdGhlIGRyb3BwaW5nIGl0ZW0gb3Igc2hvcnQtY2lyY3VpdCB0aGUgZHJvcCBiYXNlZCBvbiB0aGUgcmVzdWx0c1xuICAgICAgICAvLyBvZiB0aGUgYG9uRHJhZ092ZXIoZTogRXZlbnQpYCBjYWxsYmFjay5cbiAgICAgICAgY29uc3Qgb25EcmFnT3ZlclJlc3VsdCA9IG9uRHJvcERyYWdPdmVyPy4oZSk7IC8vIFRPRE8gZml4XG4gICAgICAgIGlmIChvbkRyYWdPdmVyUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGRyb3BwaW5nRE9NTm9kZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbERyb3BwaW5nSXRlbSA9IHsgLi4uZHJvcHBpbmdJdGVtLCAuLi5vbkRyYWdPdmVyUmVzdWx0IH07XG4gICAgICAgIC8vIFRoaXMgaXMgcmVsYXRpdmUgdG8gdGhlIERPTSBlbGVtZW50IHRoYXQgdGhpcyBldmVudCBmaXJlZCBmb3IuXG4gICAgICAgIGNvbnN0IHsgbGF5ZXJYLCBsYXllclkgfSA9IGUubmF0aXZlRXZlbnQ7IC8vIFRPRE8gZml4XG4gICAgICAgIGNvbnN0IGRyb3BwaW5nUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsZWZ0OiBsYXllclggLyB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgICAgIHRvcDogbGF5ZXJZIC8gdHJhbnNmb3JtU2NhbGUsXG4gICAgICAgICAgICBlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZHJvcHBpbmdET01Ob2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxjdWxhdGVkUG9zaXRpb24gPSBjYWxjWFkoZ2V0UG9zaXRpb25QYXJhbXMoKSwgbGF5ZXJZLCBsYXllclgsIGZpbmFsRHJvcHBpbmdJdGVtLncsIGZpbmFsRHJvcHBpbmdJdGVtLmgpO1xuICAgICAgICAgICAgc2V0RHJvcHBpbmdET01Ob2RlKF9qc3goXCJkaXZcIiwge30sIGZpbmFsRHJvcHBpbmdJdGVtLmkpKTtcbiAgICAgICAgICAgIHNldGREcm9wcGluZ1Bvc2l0aW9uKGRyb3BwaW5nUG9zaXRpb24pO1xuICAgICAgICAgICAgc2V0TGF5b3V0KFtcbiAgICAgICAgICAgICAgICAuLi5sYXlvdXQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAuLi5maW5hbERyb3BwaW5nSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgeDogY2FsY3VsYXRlZFBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNhbGN1bGF0ZWRQb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRyb3BwaW5nUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSBkcm9wcGluZ1Bvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlUG9zaXRpb24gPSBsZWZ0ICE9IGxheWVyWCB8fCB0b3AgIT0gbGF5ZXJZO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2V0ZERyb3BwaW5nUG9zaXRpb24oZHJvcHBpbmdQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0xheW91dCA9IGNvbXBhY3QobGF5b3V0LmZpbHRlcihsID0+IGwuaSAhPT0gZHJvcHBpbmdJdGVtLmkpLCBjb21wYWN0VHlwZSwgY29scywgYWxsb3dPdmVybGFwKTtcbiAgICAgICAgc2V0TGF5b3V0KG5ld0xheW91dCk7XG4gICAgICAgIHNldERyb3BwaW5nRE9NTm9kZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRBY3RpdmVEcmFnKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldGREcm9wcGluZ1Bvc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkRyYWdMZWF2ZUZuID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRyYWdFbnRlckNvdW50ZXIuY3VycmVudCA9IGRyYWdFbnRlckNvdW50ZXIuY3VycmVudCAtIDE7XG4gICAgICAgIC8vIG9uRHJhZ0xlYXZlIGNhbiBiZSB0cmlnZ2VyZWQgb24gZWFjaCBsYXlvdXQncyBjaGlsZC5cbiAgICAgICAgLy8gQnV0IHdlIGtub3cgdGhhdCBjb3VudCBvZiBkcmFnRW50ZXIgYW5kIGRyYWdMZWF2ZSBldmVudHNcbiAgICAgICAgLy8gd2lsbCBiZSBiYWxhbmNlZCBhZnRlciBsZWF2aW5nIHRoZSBsYXlvdXQncyBjb250YWluZXJcbiAgICAgICAgLy8gc28gd2UgY2FuIGluY3JlYXNlIGFuZCBkZWNyZWFzZSBjb3VudCBvZiBkcmFnRW50ZXIgYW5kXG4gICAgICAgIC8vIHdoZW4gaXQnbGwgYmUgZXF1YWwgdG8gMCB3ZSdsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIGlmIChkcmFnRW50ZXJDb3VudGVyLmN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIHJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25EcmFnRW50ZXJGbiA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYW55IGJyb3dzZXIgbmF0aXZlIGFjdGlvblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkcmFnRW50ZXJDb3VudGVyLmN1cnJlbnQgKz0gMTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRHJvcEZuID0gZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsYXlvdXQuZmluZChsID0+IGwuaSA9PT0gZHJvcHBpbmdJdGVtLmkpO1xuICAgICAgICAvLyByZXNldCBkcmFnRW50ZXIgY291bnRlciBvbiBkcm9wXG4gICAgICAgIGRyYWdFbnRlckNvdW50ZXIuY3VycmVudCA9IDA7XG4gICAgICAgIHJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgb25Ecm9wKHsgbGF5b3V0LCBpdGVtLCBldmVudDogZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlZENsYXNzTmFtZSA9IGNsc3gobGF5b3V0Q2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICAgIGNvbnN0IG1lcmdlZFN0eWxlID0ge1xuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lckhlaWdodCgpLFxuICAgICAgICAuLi5zdHlsZVxuICAgIH07XG4gICAgcmV0dXJuIChfanN4cyhcImRpdlwiLCB7IHJlZjogaW5uZXJSZWYsIGNsYXNzTmFtZTogbWVyZ2VkQ2xhc3NOYW1lLCBzdHlsZTogbWVyZ2VkU3R5bGUsIG9uRHJvcDogaXNEcm9wcGFibGUgPyBvbkRyb3BGbiA6IG5vb3AsIG9uRHJhZ0xlYXZlOiBpc0Ryb3BwYWJsZSA/IG9uRHJhZ0xlYXZlRm4gOiBub29wLCBvbkRyYWdFbnRlcjogaXNEcm9wcGFibGUgPyBvbkRyYWdFbnRlckZuIDogbm9vcCwgb25EcmFnT3ZlcjogaXNEcm9wcGFibGUgPyBvbkRyYWdPdmVyRm4gOiBub29wLCBjaGlsZHJlbjogW2NoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgID8gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBwcm9jZXNzR3JpZEl0ZW0oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICA6IHByb2Nlc3NHcmlkSXRlbShjaGlsZHJlbikpIC8vIFRPRE8gZml4IHR5cGVzXG4gICAgICAgICAgICAsIGlzRHJvcHBhYmxlICYmIGRyb3BwaW5nRE9NTm9kZSAmJiBwcm9jZXNzR3JpZEl0ZW0oZHJvcHBpbmdET01Ob2RlLCB0cnVlKSwgcGxhY2Vob2xkZXIoKV0gfSkpO1xufTtcbkdyaWRMYXlvdXQuZGlzcGxheU5hbWUgPSBcIkdyaWRMYXlvdXRcIjtcbmV4cG9ydCB7IEdyaWRMYXlvdXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWRMYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/ResponsiveGridLayout.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/ResponsiveGridLayout.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResponsiveGridLayout: () => (/* binding */ ResponsiveGridLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var fast_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\");\n/* harmony import */ var _responsiveUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/responsiveUtils.js\");\n/* harmony import */ var _GridLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GridLayout */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridLayout.js\");\n\n\n\n\n\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\nfunction getIndentationValue(param, breakpoint) {\n    if (param == null)\n        return;\n    return Array.isArray(param) ? param : param[breakpoint];\n}\nconst ResponsiveGridLayout = (properties) => {\n    const { breakpoint, compactType, breakpoints = { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }, cols = { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }, containerPadding = {}, layouts = {}, margin = [10, 10], width = 0, onBreakpointChange = _utils__WEBPACK_IMPORTED_MODULE_2__.noop, onLayoutChange = _utils__WEBPACK_IMPORTED_MODULE_2__.noop, onWidthChange = _utils__WEBPACK_IMPORTED_MODULE_2__.noop } = properties;\n    const [prevProps, setPrevProps] = react__WEBPACK_IMPORTED_MODULE_1__.useState({ width, breakpoints, cols });\n    const generateInitialState = () => {\n        const breakpoint = (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.getBreakpointFromWidth)(breakpoints, width);\n        const colNo = (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.getColsFromBreakpoint)(breakpoint, cols);\n        const compactType = properties.compactType;\n        // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n        // for this layout.\n        const initialLayout = (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType, false);\n        return {\n            layout: initialLayout,\n            layouts,\n            breakpoint: breakpoint,\n            cols: colNo\n        };\n    };\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => generateInitialState());\n    const emittedBreakpointChangeOnce = react__WEBPACK_IMPORTED_MODULE_1__.useRef(breakpoint != null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n        if (!state || !(0,fast_equals__WEBPACK_IMPORTED_MODULE_5__.deepEqual)(state.layouts, layouts)) {\n            setState(generateInitialState());\n        }\n    }, [JSON.stringify(layouts)]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n        onWidthChangeFn();\n    }, [width, breakpoint, JSON.stringify(breakpoints), JSON.stringify(cols)]);\n    // wrap layouts so we do not need to pass layouts to child\n    const onLayoutChangeFn = (layout) => {\n        const newLayouts = {\n            ...layouts,\n            [state.breakpoint]: layout\n        };\n        setState({\n            breakpoint: state.breakpoint,\n            cols: state.cols,\n            layout,\n            layouts: newLayouts\n        });\n        onLayoutChange({\n            layout,\n            layouts: newLayouts,\n            breakpoint: state.breakpoint\n        });\n    };\n    // When the width changes work through breakpoints and reset state with the new width & breakpoint.\n    // Width changes are necessary to figure out the widget widths.\n    const onWidthChangeFn = () => {\n        const newBreakpoint = breakpoint || (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.getBreakpointFromWidth)(breakpoints, width);\n        const lastBreakpoint = state.breakpoint;\n        const newCols = (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.getColsFromBreakpoint)(newBreakpoint, cols);\n        const newLayouts = { ...layouts };\n        // console.log(newBreakpoint, lastBreakpoint, width)\n        // Breakpoint change\n        if (!emittedBreakpointChangeOnce.current ||\n            lastBreakpoint !== newBreakpoint ||\n            !(0,fast_equals__WEBPACK_IMPORTED_MODULE_5__.deepEqual)(prevProps.breakpoints, breakpoints) ||\n            !(0,fast_equals__WEBPACK_IMPORTED_MODULE_5__.deepEqual)(prevProps.cols, cols)) {\n            emittedBreakpointChangeOnce.current = true;\n            // Preserve the current layout if the current breakpoint is not present in the next layouts.\n            if (!(lastBreakpoint in newLayouts)) {\n                newLayouts[lastBreakpoint] = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.cloneLayout)(state.layout);\n            }\n            const newBreakpointIsBiggerOrEqual = lastBreakpoint === newBreakpoint ||\n                breakpoints[newBreakpoint] > breakpoints[lastBreakpoint];\n            const isNewLayout = layouts[newBreakpoint] == null;\n            // Find or generate a new layout.\n            let overlap = !!properties.allowOverlap &&\n                (!isNewLayout || newBreakpointIsBiggerOrEqual); //  allow resize overlap only if we are going into a larger screen\n            let layout = (0,_responsiveUtils__WEBPACK_IMPORTED_MODULE_3__.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType, overlap);\n            // This adds missing items.\n            layout = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.synchronizeLayoutWithChildren)(layout, properties.children, newCols, compactType, overlap);\n            // Store the new layout.\n            newLayouts[newBreakpoint] = layout;\n            // Set state has to be before callback fns, so we can do change detection for props.layouts correctly\n            setState({\n                breakpoint: newBreakpoint,\n                layout: layout,\n                layouts: newLayouts,\n                cols: newCols\n            });\n            // callbacks\n            onLayoutChange({\n                layout,\n                layouts: newLayouts,\n                breakpoint: newBreakpoint\n            });\n            onBreakpointChange(newBreakpoint, newCols);\n        }\n        setPrevProps({ breakpoints, cols, width });\n        let modifiedMargin = getIndentationValue(margin, newBreakpoint);\n        const containerPaddingModified = getIndentationValue(containerPadding, newBreakpoint);\n        //call onWidthChange on every change of width, not only on breakpoint changes\n        onWidthChange(width, modifiedMargin, // TODO fix\n        newCols, containerPaddingModified);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_GridLayout__WEBPACK_IMPORTED_MODULE_4__.GridLayout, { ...properties, margin: getIndentationValue(margin, state.breakpoint), containerPadding: getIndentationValue(containerPadding, state.breakpoint), onLayoutChange: onLayoutChangeFn, layout: state.layout, cols: state.cols }));\n};\n//# sourceMappingURL=ResponsiveGridLayout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL1Jlc3BvbnNpdmVHcmlkTGF5b3V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDakI7QUFDUztBQUNtQztBQUN1QztBQUN4RTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixrREFBa0Qsa0JBQWtCO0FBQ2hHLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHlDQUF5Qyw2Q0FBNkMsV0FBVyxzQ0FBc0MsdUJBQXVCLGNBQWMscURBQXFELHdDQUFJLG1CQUFtQix3Q0FBSSxrQkFBa0Isd0NBQUksR0FBRztBQUNqUyxzQ0FBc0MsMkNBQWMsR0FBRywwQkFBMEI7QUFDakY7QUFDQSwyQkFBMkIsd0VBQXNCO0FBQ2pELHNCQUFzQix1RUFBcUI7QUFDM0M7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSw4QkFBOEIsZ0ZBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFjO0FBQzVDLHdDQUF3Qyx5Q0FBWTtBQUNwRCxJQUFJLDRDQUFlO0FBQ25CLHVCQUF1QixzREFBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3RUFBc0I7QUFDbEU7QUFDQSx3QkFBd0IsdUVBQXFCO0FBQzdDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQVM7QUFDdEIsYUFBYSxzREFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbURBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLHlCQUF5QixnRkFBOEI7QUFDdkQ7QUFDQSxxQkFBcUIscUVBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFJLENBQUMsbURBQVUsSUFBSSwyTkFBMk47QUFDMVA7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0LW5leHQvbGliL2VzbS9SZXNwb25zaXZlR3JpZExheW91dC5qcz8wYmU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gXCJmYXN0LWVxdWFsc1wiO1xuaW1wb3J0IHsgY2xvbmVMYXlvdXQsIHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuLCBub29wIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IGdldEJyZWFrcG9pbnRGcm9tV2lkdGgsIGdldENvbHNGcm9tQnJlYWtwb2ludCwgZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0IH0gZnJvbSBcIi4vcmVzcG9uc2l2ZVV0aWxzXCI7XG5pbXBvcnQgeyBHcmlkTGF5b3V0IH0gZnJvbSBcIi4vR3JpZExheW91dFwiO1xuLyoqXG4gKiBHZXQgYSB2YWx1ZSBvZiBtYXJnaW4gb3IgY29udGFpbmVyUGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheSB8IE9iamVjdH0gcGFyYW0gTWFyZ2luIHwgY29udGFpbmVyUGFkZGluZywgZS5nLiBbMTAsIDEwXSB8IHtsZzogWzEwLCAxMF0sIC4uLn0uXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgICBCcmVha3BvaW50OiBsZywgbWQsIHNtLCB4cyBhbmQgZXRjLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uVmFsdWUocGFyYW0sIGJyZWFrcG9pbnQpIHtcbiAgICBpZiAocGFyYW0gPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogcGFyYW1bYnJlYWtwb2ludF07XG59XG5leHBvcnQgY29uc3QgUmVzcG9uc2l2ZUdyaWRMYXlvdXQgPSAocHJvcGVydGllcykgPT4ge1xuICAgIGNvbnN0IHsgYnJlYWtwb2ludCwgY29tcGFjdFR5cGUsIGJyZWFrcG9pbnRzID0geyBsZzogMTIwMCwgbWQ6IDk5Niwgc206IDc2OCwgeHM6IDQ4MCwgeHhzOiAwIH0sIGNvbHMgPSB7IGxnOiAxMiwgbWQ6IDEwLCBzbTogNiwgeHM6IDQsIHh4czogMiB9LCBjb250YWluZXJQYWRkaW5nID0ge30sIGxheW91dHMgPSB7fSwgbWFyZ2luID0gWzEwLCAxMF0sIHdpZHRoID0gMCwgb25CcmVha3BvaW50Q2hhbmdlID0gbm9vcCwgb25MYXlvdXRDaGFuZ2UgPSBub29wLCBvbldpZHRoQ2hhbmdlID0gbm9vcCB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBbcHJldlByb3BzLCBzZXRQcmV2UHJvcHNdID0gUmVhY3QudXNlU3RhdGUoeyB3aWR0aCwgYnJlYWtwb2ludHMsIGNvbHMgfSk7XG4gICAgY29uc3QgZ2VuZXJhdGVJbml0aWFsU3RhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBnZXRCcmVha3BvaW50RnJvbVdpZHRoKGJyZWFrcG9pbnRzLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IGNvbE5vID0gZ2V0Q29sc0Zyb21CcmVha3BvaW50KGJyZWFrcG9pbnQsIGNvbHMpO1xuICAgICAgICBjb25zdCBjb21wYWN0VHlwZSA9IHByb3BlcnRpZXMuY29tcGFjdFR5cGU7XG4gICAgICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQuIFRoaXMgY2FuIHRyaWNreTsgd2UgdHJ5IHRvIGdlbmVyYXRlIG9uZSBob3dldmVyIHBvc3NpYmxlIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgIC8vIGZvciB0aGlzIGxheW91dC5cbiAgICAgICAgY29uc3QgaW5pdGlhbExheW91dCA9IGZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dChsYXlvdXRzLCBicmVha3BvaW50cywgYnJlYWtwb2ludCwgYnJlYWtwb2ludCwgY29sTm8sIGNvbXBhY3RUeXBlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXQ6IGluaXRpYWxMYXlvdXQsXG4gICAgICAgICAgICBsYXlvdXRzLFxuICAgICAgICAgICAgYnJlYWtwb2ludDogYnJlYWtwb2ludCxcbiAgICAgICAgICAgIGNvbHM6IGNvbE5vXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdlbmVyYXRlSW5pdGlhbFN0YXRlKCkpO1xuICAgIGNvbnN0IGVtaXR0ZWRCcmVha3BvaW50Q2hhbmdlT25jZSA9IFJlYWN0LnVzZVJlZihicmVha3BvaW50ICE9IG51bGwpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc3RhdGUgfHwgIWRlZXBFcXVhbChzdGF0ZS5sYXlvdXRzLCBsYXlvdXRzKSkge1xuICAgICAgICAgICAgc2V0U3RhdGUoZ2VuZXJhdGVJbml0aWFsU3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9LCBbSlNPTi5zdHJpbmdpZnkobGF5b3V0cyldKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBvbldpZHRoQ2hhbmdlRm4oKTtcbiAgICB9LCBbd2lkdGgsIGJyZWFrcG9pbnQsIEpTT04uc3RyaW5naWZ5KGJyZWFrcG9pbnRzKSwgSlNPTi5zdHJpbmdpZnkoY29scyldKTtcbiAgICAvLyB3cmFwIGxheW91dHMgc28gd2UgZG8gbm90IG5lZWQgdG8gcGFzcyBsYXlvdXRzIHRvIGNoaWxkXG4gICAgY29uc3Qgb25MYXlvdXRDaGFuZ2VGbiA9IChsYXlvdXQpID0+IHtcbiAgICAgICAgY29uc3QgbmV3TGF5b3V0cyA9IHtcbiAgICAgICAgICAgIC4uLmxheW91dHMsXG4gICAgICAgICAgICBbc3RhdGUuYnJlYWtwb2ludF06IGxheW91dFxuICAgICAgICB9O1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBicmVha3BvaW50OiBzdGF0ZS5icmVha3BvaW50LFxuICAgICAgICAgICAgY29sczogc3RhdGUuY29scyxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIGxheW91dHM6IG5ld0xheW91dHNcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTGF5b3V0Q2hhbmdlKHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIGxheW91dHM6IG5ld0xheW91dHMsXG4gICAgICAgICAgICBicmVha3BvaW50OiBzdGF0ZS5icmVha3BvaW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gV2hlbiB0aGUgd2lkdGggY2hhbmdlcyB3b3JrIHRocm91Z2ggYnJlYWtwb2ludHMgYW5kIHJlc2V0IHN0YXRlIHdpdGggdGhlIG5ldyB3aWR0aCAmIGJyZWFrcG9pbnQuXG4gICAgLy8gV2lkdGggY2hhbmdlcyBhcmUgbmVjZXNzYXJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHdpZGdldCB3aWR0aHMuXG4gICAgY29uc3Qgb25XaWR0aENoYW5nZUZuID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdCcmVha3BvaW50ID0gYnJlYWtwb2ludCB8fCBnZXRCcmVha3BvaW50RnJvbVdpZHRoKGJyZWFrcG9pbnRzLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IGxhc3RCcmVha3BvaW50ID0gc3RhdGUuYnJlYWtwb2ludDtcbiAgICAgICAgY29uc3QgbmV3Q29scyA9IGdldENvbHNGcm9tQnJlYWtwb2ludChuZXdCcmVha3BvaW50LCBjb2xzKTtcbiAgICAgICAgY29uc3QgbmV3TGF5b3V0cyA9IHsgLi4ubGF5b3V0cyB9O1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXdCcmVha3BvaW50LCBsYXN0QnJlYWtwb2ludCwgd2lkdGgpXG4gICAgICAgIC8vIEJyZWFrcG9pbnQgY2hhbmdlXG4gICAgICAgIGlmICghZW1pdHRlZEJyZWFrcG9pbnRDaGFuZ2VPbmNlLmN1cnJlbnQgfHxcbiAgICAgICAgICAgIGxhc3RCcmVha3BvaW50ICE9PSBuZXdCcmVha3BvaW50IHx8XG4gICAgICAgICAgICAhZGVlcEVxdWFsKHByZXZQcm9wcy5icmVha3BvaW50cywgYnJlYWtwb2ludHMpIHx8XG4gICAgICAgICAgICAhZGVlcEVxdWFsKHByZXZQcm9wcy5jb2xzLCBjb2xzKSkge1xuICAgICAgICAgICAgZW1pdHRlZEJyZWFrcG9pbnRDaGFuZ2VPbmNlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIGN1cnJlbnQgbGF5b3V0IGlmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgbGF5b3V0cy5cbiAgICAgICAgICAgIGlmICghKGxhc3RCcmVha3BvaW50IGluIG5ld0xheW91dHMpKSB7XG4gICAgICAgICAgICAgICAgbmV3TGF5b3V0c1tsYXN0QnJlYWtwb2ludF0gPSBjbG9uZUxheW91dChzdGF0ZS5sYXlvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3QnJlYWtwb2ludElzQmlnZ2VyT3JFcXVhbCA9IGxhc3RCcmVha3BvaW50ID09PSBuZXdCcmVha3BvaW50IHx8XG4gICAgICAgICAgICAgICAgYnJlYWtwb2ludHNbbmV3QnJlYWtwb2ludF0gPiBicmVha3BvaW50c1tsYXN0QnJlYWtwb2ludF07XG4gICAgICAgICAgICBjb25zdCBpc05ld0xheW91dCA9IGxheW91dHNbbmV3QnJlYWtwb2ludF0gPT0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZpbmQgb3IgZ2VuZXJhdGUgYSBuZXcgbGF5b3V0LlxuICAgICAgICAgICAgbGV0IG92ZXJsYXAgPSAhIXByb3BlcnRpZXMuYWxsb3dPdmVybGFwICYmXG4gICAgICAgICAgICAgICAgKCFpc05ld0xheW91dCB8fCBuZXdCcmVha3BvaW50SXNCaWdnZXJPckVxdWFsKTsgLy8gIGFsbG93IHJlc2l6ZSBvdmVybGFwIG9ubHkgaWYgd2UgYXJlIGdvaW5nIGludG8gYSBsYXJnZXIgc2NyZWVuXG4gICAgICAgICAgICBsZXQgbGF5b3V0ID0gZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KG5ld0xheW91dHMsIGJyZWFrcG9pbnRzLCBuZXdCcmVha3BvaW50LCBsYXN0QnJlYWtwb2ludCwgbmV3Q29scywgY29tcGFjdFR5cGUsIG92ZXJsYXApO1xuICAgICAgICAgICAgLy8gVGhpcyBhZGRzIG1pc3NpbmcgaXRlbXMuXG4gICAgICAgICAgICBsYXlvdXQgPSBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbihsYXlvdXQsIHByb3BlcnRpZXMuY2hpbGRyZW4sIG5ld0NvbHMsIGNvbXBhY3RUeXBlLCBvdmVybGFwKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgICAgICAgbmV3TGF5b3V0c1tuZXdCcmVha3BvaW50XSA9IGxheW91dDtcbiAgICAgICAgICAgIC8vIFNldCBzdGF0ZSBoYXMgdG8gYmUgYmVmb3JlIGNhbGxiYWNrIGZucywgc28gd2UgY2FuIGRvIGNoYW5nZSBkZXRlY3Rpb24gZm9yIHByb3BzLmxheW91dHMgY29ycmVjdGx5XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYnJlYWtwb2ludDogbmV3QnJlYWtwb2ludCxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICBsYXlvdXRzOiBuZXdMYXlvdXRzLFxuICAgICAgICAgICAgICAgIGNvbHM6IG5ld0NvbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2FsbGJhY2tzXG4gICAgICAgICAgICBvbkxheW91dENoYW5nZSh7XG4gICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgIGxheW91dHM6IG5ld0xheW91dHMsXG4gICAgICAgICAgICAgICAgYnJlYWtwb2ludDogbmV3QnJlYWtwb2ludFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbkJyZWFrcG9pbnRDaGFuZ2UobmV3QnJlYWtwb2ludCwgbmV3Q29scyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJldlByb3BzKHsgYnJlYWtwb2ludHMsIGNvbHMsIHdpZHRoIH0pO1xuICAgICAgICBsZXQgbW9kaWZpZWRNYXJnaW4gPSBnZXRJbmRlbnRhdGlvblZhbHVlKG1hcmdpbiwgbmV3QnJlYWtwb2ludCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmdNb2RpZmllZCA9IGdldEluZGVudGF0aW9uVmFsdWUoY29udGFpbmVyUGFkZGluZywgbmV3QnJlYWtwb2ludCk7XG4gICAgICAgIC8vY2FsbCBvbldpZHRoQ2hhbmdlIG9uIGV2ZXJ5IGNoYW5nZSBvZiB3aWR0aCwgbm90IG9ubHkgb24gYnJlYWtwb2ludCBjaGFuZ2VzXG4gICAgICAgIG9uV2lkdGhDaGFuZ2Uod2lkdGgsIG1vZGlmaWVkTWFyZ2luLCAvLyBUT0RPIGZpeFxuICAgICAgICBuZXdDb2xzLCBjb250YWluZXJQYWRkaW5nTW9kaWZpZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIChfanN4KEdyaWRMYXlvdXQsIHsgLi4ucHJvcGVydGllcywgbWFyZ2luOiBnZXRJbmRlbnRhdGlvblZhbHVlKG1hcmdpbiwgc3RhdGUuYnJlYWtwb2ludCksIGNvbnRhaW5lclBhZGRpbmc6IGdldEluZGVudGF0aW9uVmFsdWUoY29udGFpbmVyUGFkZGluZywgc3RhdGUuYnJlYWtwb2ludCksIG9uTGF5b3V0Q2hhbmdlOiBvbkxheW91dENoYW5nZUZuLCBsYXlvdXQ6IHN0YXRlLmxheW91dCwgY29sczogc3RhdGUuY29scyB9KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2l2ZUdyaWRMYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/ResponsiveGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcGridColWidth: () => (/* binding */ calcGridColWidth),\n/* harmony export */   calcGridItemPosition: () => (/* binding */ calcGridItemPosition),\n/* harmony export */   calcGridItemWHPx: () => (/* binding */ calcGridItemWHPx),\n/* harmony export */   calcWH: () => (/* binding */ calcWH),\n/* harmony export */   calcXY: () => (/* binding */ calcXY),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   resolveRowHeight: () => (/* binding */ resolveRowHeight)\n/* harmony export */ });\n// Helper for generating column width\nfunction calcGridColWidth(positionParams) {\n    const { margin, containerPadding, containerWidth, cols } = positionParams;\n    return ((containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols);\n}\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {\n    // 0 * Infinity === NaN, which causes problems with resize contraints\n    if (!Number.isFinite(gridUnits))\n        return gridUnits;\n    return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\nconst resolveRowHeight = (rowHeight, width) => typeof rowHeight === \"number\" ? rowHeight : rowHeight(width);\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n */\nfunction calcGridItemPosition(positionParams, x, y, z, w, h, state) {\n    const { margin, containerPadding, rowHeight } = positionParams;\n    const colWidth = calcGridColWidth(positionParams);\n    const out = {};\n    const rowHeightNumber = resolveRowHeight(rowHeight, colWidth);\n    // If resizing, use the exact width and height as returned from resizing callbacks.\n    if (state && state.resizing) {\n        out.width = Math.round(state.resizing.width);\n        out.height = Math.round(state.resizing.height);\n    }\n    // Otherwise, calculate from grid units.\n    else {\n        out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n        out.height = calcGridItemWHPx(h, rowHeightNumber, margin[1]);\n    }\n    // If dragging, use the exact width and height as returned from dragging callbacks.\n    if (state && state.dragging) {\n        out.top = Math.round(state.dragging.top);\n        out.left = Math.round(state.dragging.left);\n    }\n    // Otherwise, calculate from grid units.\n    else {\n        out.top = Math.round((rowHeightNumber + margin[1]) * y + containerPadding[1]);\n        out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n    }\n    out.z = z;\n    return out;\n}\n/**\n * Translate x and y coordinates from pixels to grid units.\n */\nfunction calcXY(positionParams, top, left, w, h) {\n    const { margin, cols, rowHeight, maxRows } = positionParams;\n    const colWidth = calcGridColWidth(positionParams);\n    const rowHeightNumber = resolveRowHeight(rowHeight, colWidth);\n    // left = colWidth * x + margin * (x + 1)\n    // l = cx + m(x+1)\n    // l = cx + mx + m\n    // l - m = cx + mx\n    // l - m = x(c + m)\n    // (l - m) / (c + m) = x\n    // x = (left - margin) / (coldWidth + margin)\n    let x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n    let y = Math.round((top - margin[1]) / (rowHeightNumber + margin[1]));\n    // Capping\n    x = clamp(x, 0, cols - w);\n    y = clamp(y, 0, maxRows - h);\n    return { x, y };\n}\n/**\n * Given a height and width in pixel values, calculate grid units.\n */\nfunction calcWH(positionParams, width, height, x, y) {\n    const { margin, maxRows, cols, rowHeight } = positionParams;\n    const colWidth = calcGridColWidth(positionParams);\n    const rowHeightNumber = resolveRowHeight(rowHeight, colWidth);\n    // width = colWidth * w - (margin * (w - 1))\n    // ...\n    // w = (width + margin) / (colWidth + margin)\n    let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n    let h = Math.round((height + margin[1]) / (rowHeightNumber + margin[1]));\n    // Capping\n    w = clamp(w, 0, cols - x);\n    h = clamp(h, 0, maxRows - y);\n    return { w, h };\n}\n// Similar to _.clamp\nfunction clamp(num, lowerBound, upperBound) {\n    return Math.max(Math.min(num, upperBound), lowerBound);\n}\n//# sourceMappingURL=calculateUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL2NhbGN1bGF0ZVV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1AsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL2NhbGN1bGF0ZVV0aWxzLmpzPzY0YmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSGVscGVyIGZvciBnZW5lcmF0aW5nIGNvbHVtbiB3aWR0aFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpIHtcbiAgICBjb25zdCB7IG1hcmdpbiwgY29udGFpbmVyUGFkZGluZywgY29udGFpbmVyV2lkdGgsIGNvbHMgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICAgIHJldHVybiAoKGNvbnRhaW5lcldpZHRoIC0gbWFyZ2luWzBdICogKGNvbHMgLSAxKSAtIGNvbnRhaW5lclBhZGRpbmdbMF0gKiAyKSAvIGNvbHMpO1xufVxuLy8gVGhpcyBjYW4gZWl0aGVyIGJlIGNhbGxlZDpcbi8vIGNhbGNHcmlkSXRlbVdIUHgodywgY29sV2lkdGgsIG1hcmdpblswXSlcbi8vIG9yXG4vLyBjYWxjR3JpZEl0ZW1XSFB4KGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNHcmlkSXRlbVdIUHgoZ3JpZFVuaXRzLCBjb2xPclJvd1NpemUsIG1hcmdpblB4KSB7XG4gICAgLy8gMCAqIEluZmluaXR5ID09PSBOYU4sIHdoaWNoIGNhdXNlcyBwcm9ibGVtcyB3aXRoIHJlc2l6ZSBjb250cmFpbnRzXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZ3JpZFVuaXRzKSlcbiAgICAgICAgcmV0dXJuIGdyaWRVbml0cztcbiAgICByZXR1cm4gTWF0aC5yb3VuZChjb2xPclJvd1NpemUgKiBncmlkVW5pdHMgKyBNYXRoLm1heCgwLCBncmlkVW5pdHMgLSAxKSAqIG1hcmdpblB4KTtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlUm93SGVpZ2h0ID0gKHJvd0hlaWdodCwgd2lkdGgpID0+IHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIgPyByb3dIZWlnaHQgOiByb3dIZWlnaHQod2lkdGgpO1xuLyoqXG4gKiBSZXR1cm4gcG9zaXRpb24gb24gdGhlIHBhZ2UgZ2l2ZW4gYW4geCwgeSwgdywgaC5cbiAqIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBhcmUgYWxsIGluIHBpeGVscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNHcmlkSXRlbVBvc2l0aW9uKHBvc2l0aW9uUGFyYW1zLCB4LCB5LCB6LCB3LCBoLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgbWFyZ2luLCBjb250YWluZXJQYWRkaW5nLCByb3dIZWlnaHQgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICAgIGNvbnN0IGNvbFdpZHRoID0gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyk7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgY29uc3Qgcm93SGVpZ2h0TnVtYmVyID0gcmVzb2x2ZVJvd0hlaWdodChyb3dIZWlnaHQsIGNvbFdpZHRoKTtcbiAgICAvLyBJZiByZXNpemluZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gcmVzaXppbmcgY2FsbGJhY2tzLlxuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5yZXNpemluZykge1xuICAgICAgICBvdXQud2lkdGggPSBNYXRoLnJvdW5kKHN0YXRlLnJlc2l6aW5nLndpZHRoKTtcbiAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcuaGVpZ2h0KTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICAgIGVsc2Uge1xuICAgICAgICBvdXQud2lkdGggPSBjYWxjR3JpZEl0ZW1XSFB4KHcsIGNvbFdpZHRoLCBtYXJnaW5bMF0pO1xuICAgICAgICBvdXQuaGVpZ2h0ID0gY2FsY0dyaWRJdGVtV0hQeChoLCByb3dIZWlnaHROdW1iZXIsIG1hcmdpblsxXSk7XG4gICAgfVxuICAgIC8vIElmIGRyYWdnaW5nLCB1c2UgdGhlIGV4YWN0IHdpZHRoIGFuZCBoZWlnaHQgYXMgcmV0dXJuZWQgZnJvbSBkcmFnZ2luZyBjYWxsYmFja3MuXG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgIG91dC50b3AgPSBNYXRoLnJvdW5kKHN0YXRlLmRyYWdnaW5nLnRvcCk7XG4gICAgICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy5sZWZ0KTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICAgIGVsc2Uge1xuICAgICAgICBvdXQudG9wID0gTWF0aC5yb3VuZCgocm93SGVpZ2h0TnVtYmVyICsgbWFyZ2luWzFdKSAqIHkgKyBjb250YWluZXJQYWRkaW5nWzFdKTtcbiAgICAgICAgb3V0LmxlZnQgPSBNYXRoLnJvdW5kKChjb2xXaWR0aCArIG1hcmdpblswXSkgKiB4ICsgY29udGFpbmVyUGFkZGluZ1swXSk7XG4gICAgfVxuICAgIG91dC56ID0gejtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgeCBhbmQgeSBjb29yZGluYXRlcyBmcm9tIHBpeGVscyB0byBncmlkIHVuaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY1hZKHBvc2l0aW9uUGFyYW1zLCB0b3AsIGxlZnQsIHcsIGgpIHtcbiAgICBjb25zdCB7IG1hcmdpbiwgY29scywgcm93SGVpZ2h0LCBtYXhSb3dzIH0gPSBwb3NpdGlvblBhcmFtcztcbiAgICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuICAgIGNvbnN0IHJvd0hlaWdodE51bWJlciA9IHJlc29sdmVSb3dIZWlnaHQocm93SGVpZ2h0LCBjb2xXaWR0aCk7XG4gICAgLy8gbGVmdCA9IGNvbFdpZHRoICogeCArIG1hcmdpbiAqICh4ICsgMSlcbiAgICAvLyBsID0gY3ggKyBtKHgrMSlcbiAgICAvLyBsID0gY3ggKyBteCArIG1cbiAgICAvLyBsIC0gbSA9IGN4ICsgbXhcbiAgICAvLyBsIC0gbSA9IHgoYyArIG0pXG4gICAgLy8gKGwgLSBtKSAvIChjICsgbSkgPSB4XG4gICAgLy8geCA9IChsZWZ0IC0gbWFyZ2luKSAvIChjb2xkV2lkdGggKyBtYXJnaW4pXG4gICAgbGV0IHggPSBNYXRoLnJvdW5kKChsZWZ0IC0gbWFyZ2luWzBdKSAvIChjb2xXaWR0aCArIG1hcmdpblswXSkpO1xuICAgIGxldCB5ID0gTWF0aC5yb3VuZCgodG9wIC0gbWFyZ2luWzFdKSAvIChyb3dIZWlnaHROdW1iZXIgKyBtYXJnaW5bMV0pKTtcbiAgICAvLyBDYXBwaW5nXG4gICAgeCA9IGNsYW1wKHgsIDAsIGNvbHMgLSB3KTtcbiAgICB5ID0gY2xhbXAoeSwgMCwgbWF4Um93cyAtIGgpO1xuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cbi8qKlxuICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjV0gocG9zaXRpb25QYXJhbXMsIHdpZHRoLCBoZWlnaHQsIHgsIHkpIHtcbiAgICBjb25zdCB7IG1hcmdpbiwgbWF4Um93cywgY29scywgcm93SGVpZ2h0IH0gPSBwb3NpdGlvblBhcmFtcztcbiAgICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuICAgIGNvbnN0IHJvd0hlaWdodE51bWJlciA9IHJlc29sdmVSb3dIZWlnaHQocm93SGVpZ2h0LCBjb2xXaWR0aCk7XG4gICAgLy8gd2lkdGggPSBjb2xXaWR0aCAqIHcgLSAobWFyZ2luICogKHcgLSAxKSlcbiAgICAvLyAuLi5cbiAgICAvLyB3ID0gKHdpZHRoICsgbWFyZ2luKSAvIChjb2xXaWR0aCArIG1hcmdpbilcbiAgICBsZXQgdyA9IE1hdGgucm91bmQoKHdpZHRoICsgbWFyZ2luWzBdKSAvIChjb2xXaWR0aCArIG1hcmdpblswXSkpO1xuICAgIGxldCBoID0gTWF0aC5yb3VuZCgoaGVpZ2h0ICsgbWFyZ2luWzFdKSAvIChyb3dIZWlnaHROdW1iZXIgKyBtYXJnaW5bMV0pKTtcbiAgICAvLyBDYXBwaW5nXG4gICAgdyA9IGNsYW1wKHcsIDAsIGNvbHMgLSB4KTtcbiAgICBoID0gY2xhbXAoaCwgMCwgbWF4Um93cyAtIHkpO1xuICAgIHJldHVybiB7IHcsIGggfTtcbn1cbi8vIFNpbWlsYXIgdG8gXy5jbGFtcFxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKG51bSwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihudW0sIHVwcGVyQm91bmQpLCBsb3dlckJvdW5kKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGN1bGF0ZVV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/components/WidthProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/components/WidthProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WidthProvider: () => (/* binding */ WidthProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\");\n\n\n\nconst layoutClassName = \"react-grid-layout\";\n/*\n * A simple HOC that provides facility for listening to container resizes.\n */\nconst WidthProvider = (ComposedComponent) => {\n    return (props) => {\n        const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n        const mounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n        const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n            width: props.width ?? 1280\n        });\n        const { measureBeforeMount = false } = props;\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n            if (mounted.current) {\n                return;\n            }\n            mounted.current = true;\n            window.addEventListener(\"resize\", onWindowResize);\n            // Call to properly set the breakpoint and resize the elements.\n            // Note that if you're doing a full-width element, this can get a little wonky if a scrollbar\n            // appears because of the grid. In that case, fire your own resize event, or set `overflow: scroll` on your body.\n            onWindowResize();\n            return () => {\n                mounted.current = false;\n                window.removeEventListener(\"resize\", onWindowResize);\n            };\n        }, []);\n        const onWindowResize = () => {\n            if (!mounted.current)\n                return;\n            const node = elementRef.current; // Flow casts this to Text | Element\n            // fix: grid position error when node or parentNode display is none by window resize\n            // #924 #1084\n            if (node instanceof HTMLElement && node.offsetWidth) {\n                setState({ width: node.offsetWidth });\n            }\n        };\n        if (measureBeforeMount && !mounted.current) {\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(props.className, layoutClassName), style: props.style, ref: elementRef }));\n        }\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ComposedComponent, { ...props, innerRef: elementRef, ...state });\n    };\n};\n//# sourceMappingURL=WidthProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdEO0FBQ0k7QUFDNUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCLDZDQUFNO0FBQ2pDLHdCQUF3Qiw2Q0FBTTtBQUM5QixrQ0FBa0MsK0NBQVE7QUFDMUM7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLDZCQUE2QjtBQUM3QyxRQUFRLGdEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBSSxVQUFVLFdBQVcsZ0RBQUkseUVBQXlFO0FBQzFIO0FBQ0EsZUFBZSxzREFBSSxzQkFBc0IsMENBQTBDO0FBQ25GO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0LW5leHQvbGliL2VzbS9jb21wb25lbnRzL1dpZHRoUHJvdmlkZXIuanM/N2JmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuY29uc3QgbGF5b3V0Q2xhc3NOYW1lID0gXCJyZWFjdC1ncmlkLWxheW91dFwiO1xuLypcbiAqIEEgc2ltcGxlIEhPQyB0aGF0IHByb3ZpZGVzIGZhY2lsaXR5IGZvciBsaXN0ZW5pbmcgdG8gY29udGFpbmVyIHJlc2l6ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBXaWR0aFByb3ZpZGVyID0gKENvbXBvc2VkQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIChwcm9wcykgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgICBjb25zdCBtb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGggPz8gMTI4MFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlQmVmb3JlTW91bnQgPSBmYWxzZSB9ID0gcHJvcHM7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uV2luZG93UmVzaXplKTtcbiAgICAgICAgICAgIC8vIENhbGwgdG8gcHJvcGVybHkgc2V0IHRoZSBicmVha3BvaW50IGFuZCByZXNpemUgdGhlIGVsZW1lbnRzLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGlmIHlvdSdyZSBkb2luZyBhIGZ1bGwtd2lkdGggZWxlbWVudCwgdGhpcyBjYW4gZ2V0IGEgbGl0dGxlIHdvbmt5IGlmIGEgc2Nyb2xsYmFyXG4gICAgICAgICAgICAvLyBhcHBlYXJzIGJlY2F1c2Ugb2YgdGhlIGdyaWQuIEluIHRoYXQgY2FzZSwgZmlyZSB5b3VyIG93biByZXNpemUgZXZlbnQsIG9yIHNldCBgb3ZlcmZsb3c6IHNjcm9sbGAgb24geW91ciBib2R5LlxuICAgICAgICAgICAgb25XaW5kb3dSZXNpemUoKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25XaW5kb3dSZXNpemUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBjb25zdCBvbldpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghbW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50UmVmLmN1cnJlbnQ7IC8vIEZsb3cgY2FzdHMgdGhpcyB0byBUZXh0IHwgRWxlbWVudFxuICAgICAgICAgICAgLy8gZml4OiBncmlkIHBvc2l0aW9uIGVycm9yIHdoZW4gbm9kZSBvciBwYXJlbnROb2RlIGRpc3BsYXkgaXMgbm9uZSBieSB3aW5kb3cgcmVzaXplXG4gICAgICAgICAgICAvLyAjOTI0ICMxMDg0XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG5vZGUub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZSh7IHdpZHRoOiBub2RlLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWVhc3VyZUJlZm9yZU1vdW50ICYmICFtb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeChwcm9wcy5jbGFzc05hbWUsIGxheW91dENsYXNzTmFtZSksIHN0eWxlOiBwcm9wcy5zdHlsZSwgcmVmOiBlbGVtZW50UmVmIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2pzeChDb21wb3NlZENvbXBvbmVudCwgeyAuLi5wcm9wcywgaW5uZXJSZWY6IGVsZW1lbnRSZWYsIC4uLnN0YXRlIH0pO1xuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2lkdGhQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/components/WidthProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* reexport safe */ _GridLayout__WEBPACK_IMPORTED_MODULE_0__.GridLayout),\n/* harmony export */   ResponsiveGridLayout: () => (/* reexport safe */ _ResponsiveGridLayout__WEBPACK_IMPORTED_MODULE_3__.ResponsiveGridLayout),\n/* harmony export */   WidthProvider: () => (/* reexport safe */ _components_WidthProvider__WEBPACK_IMPORTED_MODULE_2__.WidthProvider),\n/* harmony export */   bottom: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.bottom),\n/* harmony export */   calcGridColWidth: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcGridColWidth),\n/* harmony export */   calcGridItemPosition: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcGridItemPosition),\n/* harmony export */   calcGridItemWHPx: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcGridItemWHPx),\n/* harmony export */   calcWH: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcWH),\n/* harmony export */   calcXY: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.calcXY),\n/* harmony export */   childrenEqual: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.childrenEqual),\n/* harmony export */   clamp: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.clamp),\n/* harmony export */   cloneLayout: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.cloneLayout),\n/* harmony export */   cloneLayoutItem: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.cloneLayoutItem),\n/* harmony export */   collides: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.collides),\n/* harmony export */   compact: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.compact),\n/* harmony export */   compactItem: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.compactItem),\n/* harmony export */   correctBounds: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.correctBounds),\n/* harmony export */   fastPositionEqual: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.fastPositionEqual),\n/* harmony export */   getAllCollisions: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.getAllCollisions),\n/* harmony export */   getFirstCollision: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.getFirstCollision),\n/* harmony export */   getLayoutItem: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.getLayoutItem),\n/* harmony export */   getStatics: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.getStatics),\n/* harmony export */   modifyLayout: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.modifyLayout),\n/* harmony export */   moveElement: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.moveElement),\n/* harmony export */   moveElementAwayFromCollision: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.moveElementAwayFromCollision),\n/* harmony export */   noop: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   perc: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.perc),\n/* harmony export */   resolveRowHeight: () => (/* reexport safe */ _calculateUtils__WEBPACK_IMPORTED_MODULE_4__.resolveRowHeight),\n/* harmony export */   setTopLeft: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.setTopLeft),\n/* harmony export */   setTransform: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.setTransform),\n/* harmony export */   sortLayoutItems: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.sortLayoutItems),\n/* harmony export */   sortLayoutItemsByColRow: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.sortLayoutItemsByColRow),\n/* harmony export */   sortLayoutItemsByRowCol: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.sortLayoutItemsByRowCol),\n/* harmony export */   synchronizeLayoutWithChildren: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.synchronizeLayoutWithChildren),\n/* harmony export */   validateLayout: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.validateLayout),\n/* harmony export */   withLayoutItem: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.withLayoutItem)\n/* harmony export */ });\n/* harmony import */ var _GridLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GridLayout */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/GridLayout.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\");\n/* harmony import */ var _components_WidthProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/WidthProvider */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/components/WidthProvider.js\");\n/* harmony import */ var _ResponsiveGridLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ResponsiveGridLayout */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/ResponsiveGridLayout.js\");\n/* harmony import */ var _calculateUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/calculateUtils.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0w7QUFDbUI7QUFDSjtBQUNOO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL2luZGV4LmpzP2JiY2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vR3JpZExheW91dFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vUmVzcG9uc2l2ZUdyaWRMYXlvdXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NhbGN1bGF0ZVV0aWxzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/responsiveUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/responsiveUtils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findOrGenerateResponsiveLayout: () => (/* binding */ findOrGenerateResponsiveLayout),\n/* harmony export */   getBreakpointFromWidth: () => (/* binding */ getBreakpointFromWidth),\n/* harmony export */   getColsFromBreakpoint: () => (/* binding */ getColsFromBreakpoint),\n/* harmony export */   sortBreakpoints: () => (/* binding */ sortBreakpoints)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\");\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n */\nfunction getBreakpointFromWidth(breakpoints, width) {\n    const sorted = sortBreakpoints(breakpoints);\n    let matching = sorted[0];\n    for (let i = 1, len = sorted.length; i < len; i++) {\n        const breakpointName = sorted[i];\n        if (width > breakpoints[breakpointName])\n            matching = breakpointName;\n    }\n    return matching;\n}\n/**\n * Given a breakpoint, get the # of cols set for it.\n */\nfunction getColsFromBreakpoint(breakpoint, cols) {\n    if (!cols[breakpoint]) {\n        throw new Error(\"ResponsiveGridLayout: `cols` entry for breakpoint \" +\n            breakpoint +\n            \" is missing!\");\n    }\n    return cols[breakpoint];\n}\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n */\nfunction findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType, overlap) {\n    // If it already exists, just return it.\n    if (layouts[breakpoint]) {\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.cloneLayout)(layouts[breakpoint]);\n    }\n    // Find or generate the next layout\n    let layout = layouts[lastBreakpoint];\n    const breakpointsSorted = sortBreakpoints(breakpoints);\n    // Above?\n    for (let i = breakpointsSorted.indexOf(breakpoint); i < breakpointsSorted.length; i++) {\n        const b = breakpointsSorted[i];\n        if (layouts[b]) {\n            layout = layouts[b];\n            break;\n        }\n    }\n    if (!layout) {\n        // below?\n        for (let i = breakpointsSorted.indexOf(breakpoint) - 1; i >= 0; i--) {\n            const b = breakpointsSorted[i];\n            if (layouts[b]) {\n                layout = layouts[b];\n                break;\n            }\n        }\n    }\n    layout = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n    return overlap\n        ? layout\n        : (0,_utils__WEBPACK_IMPORTED_MODULE_0__.compact)((0,_utils__WEBPACK_IMPORTED_MODULE_0__.correctBounds)(layout, { cols: cols }), compactType, cols);\n}\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints) {\n    const keys = Object.keys(breakpoints);\n    return keys.sort(function (a, b) {\n        return breakpoints[a] - breakpoints[b];\n    });\n}\n//# sourceMappingURL=responsiveUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL3Jlc3BvbnNpdmVVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsc0NBQXNDLHVCQUF1QjtBQUNqRixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsbURBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVyxnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLFVBQVUsK0NBQU8sQ0FBQyxxREFBYSxXQUFXLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLG9CQUFvQjtBQUNoQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC1uZXh0L2xpYi9lc20vcmVzcG9uc2l2ZVV0aWxzLmpzP2YyMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVMYXlvdXQsIGNvbXBhY3QsIGNvcnJlY3RCb3VuZHMgfSBmcm9tIFwiLi91dGlsc1wiO1xuLyoqXG4gKiBHaXZlbiBhIHdpZHRoLCBmaW5kIHRoZSBoaWdoZXN0IGJyZWFrcG9pbnQgdGhhdCBtYXRjaGVzIGlzIHZhbGlkIGZvciBpdCAod2lkdGggPiBicmVha3BvaW50KS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJyZWFrcG9pbnRzIEJyZWFrcG9pbnRzIG9iamVjdCAoZS5nLiB7bGc6IDEyMDAsIG1kOiA5NjAsIC4uLn0pXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoIFNjcmVlbiB3aWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJyZWFrcG9pbnRGcm9tV2lkdGgoYnJlYWtwb2ludHMsIHdpZHRoKSB7XG4gICAgY29uc3Qgc29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgICBsZXQgbWF0Y2hpbmcgPSBzb3J0ZWRbMF07XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBicmVha3BvaW50TmFtZSA9IHNvcnRlZFtpXTtcbiAgICAgICAgaWYgKHdpZHRoID4gYnJlYWtwb2ludHNbYnJlYWtwb2ludE5hbWVdKVxuICAgICAgICAgICAgbWF0Y2hpbmcgPSBicmVha3BvaW50TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoaW5nO1xufVxuLyoqXG4gKiBHaXZlbiBhIGJyZWFrcG9pbnQsIGdldCB0aGUgIyBvZiBjb2xzIHNldCBmb3IgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xzRnJvbUJyZWFrcG9pbnQoYnJlYWtwb2ludCwgY29scykge1xuICAgIGlmICghY29sc1ticmVha3BvaW50XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zaXZlR3JpZExheW91dDogYGNvbHNgIGVudHJ5IGZvciBicmVha3BvaW50IFwiICtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQgK1xuICAgICAgICAgICAgXCIgaXMgbWlzc2luZyFcIik7XG4gICAgfVxuICAgIHJldHVybiBjb2xzW2JyZWFrcG9pbnRdO1xufVxuLyoqXG4gKiBHaXZlbiBleGlzdGluZyBsYXlvdXRzIGFuZCBhIG5ldyBicmVha3BvaW50LCBmaW5kIG9yIGdlbmVyYXRlIGEgbmV3IGxheW91dC5cbiAqXG4gKiBUaGlzIGZpbmRzIHRoZSBsYXlvdXQgYWJvdmUgdGhlIG5ldyBvbmUgYW5kIGdlbmVyYXRlcyBmcm9tIGl0LCBpZiBpdCBleGlzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQobGF5b3V0cywgYnJlYWtwb2ludHMsIGJyZWFrcG9pbnQsIGxhc3RCcmVha3BvaW50LCBjb2xzLCBjb21wYWN0VHlwZSwgb3ZlcmxhcCkge1xuICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJldHVybiBpdC5cbiAgICBpZiAobGF5b3V0c1ticmVha3BvaW50XSkge1xuICAgICAgICByZXR1cm4gY2xvbmVMYXlvdXQobGF5b3V0c1ticmVha3BvaW50XSk7XG4gICAgfVxuICAgIC8vIEZpbmQgb3IgZ2VuZXJhdGUgdGhlIG5leHQgbGF5b3V0XG4gICAgbGV0IGxheW91dCA9IGxheW91dHNbbGFzdEJyZWFrcG9pbnRdO1xuICAgIGNvbnN0IGJyZWFrcG9pbnRzU29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgICAvLyBBYm92ZT9cbiAgICBmb3IgKGxldCBpID0gYnJlYWtwb2ludHNTb3J0ZWQuaW5kZXhPZihicmVha3BvaW50KTsgaSA8IGJyZWFrcG9pbnRzU29ydGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSBicmVha3BvaW50c1NvcnRlZFtpXTtcbiAgICAgICAgaWYgKGxheW91dHNbYl0pIHtcbiAgICAgICAgICAgIGxheW91dCA9IGxheW91dHNbYl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxheW91dCkge1xuICAgICAgICAvLyBiZWxvdz9cbiAgICAgICAgZm9yIChsZXQgaSA9IGJyZWFrcG9pbnRzU29ydGVkLmluZGV4T2YoYnJlYWtwb2ludCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgYiA9IGJyZWFrcG9pbnRzU29ydGVkW2ldO1xuICAgICAgICAgICAgaWYgKGxheW91dHNbYl0pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQgPSBsYXlvdXRzW2JdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxheW91dCA9IGNsb25lTGF5b3V0KGxheW91dCB8fCBbXSk7IC8vIGNsb25lIGxheW91dCBzbyB3ZSBkb24ndCBtb2RpZnkgZXhpc3RpbmcgaXRlbXNcbiAgICByZXR1cm4gb3ZlcmxhcFxuICAgICAgICA/IGxheW91dFxuICAgICAgICA6IGNvbXBhY3QoY29ycmVjdEJvdW5kcyhsYXlvdXQsIHsgY29sczogY29scyB9KSwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuLyoqXG4gKiBHaXZlbiBicmVha3BvaW50cywgcmV0dXJuIGFuIGFycmF5IG9mIGJyZWFrcG9pbnRzIHNvcnRlZCBieSB3aWR0aC4gVGhpcyBpcyB1c3VhbGx5XG4gKiBlLmcuIFsneHhzJywgJ3hzJywgJ3NtJywgLi4uXVxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYnJlYWtwb2ludHMgS2V5L3ZhbHVlIHBhaXIgb2YgYnJlYWtwb2ludCBuYW1lcyB0byB3aWR0aHMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFNvcnRlZCBicmVha3BvaW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cyk7XG4gICAgcmV0dXJuIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYnJlYWtwb2ludHNbYV0gLSBicmVha3BvaW50c1tiXTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNpdmVVdGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/responsiveUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-grid-layout-next/lib/esm/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   childrenEqual: () => (/* binding */ childrenEqual),\n/* harmony export */   cloneLayout: () => (/* binding */ cloneLayout),\n/* harmony export */   cloneLayoutItem: () => (/* binding */ cloneLayoutItem),\n/* harmony export */   collides: () => (/* binding */ collides),\n/* harmony export */   compact: () => (/* binding */ compact),\n/* harmony export */   compactItem: () => (/* binding */ compactItem),\n/* harmony export */   correctBounds: () => (/* binding */ correctBounds),\n/* harmony export */   fastPositionEqual: () => (/* binding */ fastPositionEqual),\n/* harmony export */   getAllCollisions: () => (/* binding */ getAllCollisions),\n/* harmony export */   getFirstCollision: () => (/* binding */ getFirstCollision),\n/* harmony export */   getLayoutItem: () => (/* binding */ getLayoutItem),\n/* harmony export */   getStatics: () => (/* binding */ getStatics),\n/* harmony export */   modifyLayout: () => (/* binding */ modifyLayout),\n/* harmony export */   moveElement: () => (/* binding */ moveElement),\n/* harmony export */   moveElementAwayFromCollision: () => (/* binding */ moveElementAwayFromCollision),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   perc: () => (/* binding */ perc),\n/* harmony export */   setTopLeft: () => (/* binding */ setTopLeft),\n/* harmony export */   setTransform: () => (/* binding */ setTransform),\n/* harmony export */   sortLayoutItems: () => (/* binding */ sortLayoutItems),\n/* harmony export */   sortLayoutItemsByColRow: () => (/* binding */ sortLayoutItemsByColRow),\n/* harmony export */   sortLayoutItemsByRowCol: () => (/* binding */ sortLayoutItemsByRowCol),\n/* harmony export */   synchronizeLayoutWithChildren: () => (/* binding */ synchronizeLayoutWithChildren),\n/* harmony export */   validateLayout: () => (/* binding */ validateLayout),\n/* harmony export */   withLayoutItem: () => (/* binding */ withLayoutItem)\n/* harmony export */ });\n/* harmony import */ var fast_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst isProduction = \"development\" === \"production\";\nconst DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout) {\n    let max = 0, bottomY;\n    for (let i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max)\n            max = bottomY;\n    }\n    return max;\n}\nfunction cloneLayout(layout) {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n    }\n    return newLayout;\n}\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout, layoutItem) {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layoutItem.i === layout[i].i) {\n            newLayout[i] = layoutItem;\n        }\n        else {\n            newLayout[i] = layout[i];\n        }\n    }\n    return newLayout;\n}\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout, itemKey, cb) {\n    let item = getLayoutItem(layout, itemKey);\n    if (!item)\n        return [layout, null];\n    item = cb(cloneLayoutItem(item)); // defensive clone then modify\n    // FIXME could do this faster if we already knew the index\n    layout = modifyLayout(layout, item);\n    return [layout, item];\n}\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem) {\n    return {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        z: layoutItem.z,\n        i: layoutItem.i,\n        minW: layoutItem.minW,\n        maxW: layoutItem.maxW,\n        minH: layoutItem.minH,\n        maxH: layoutItem.maxH,\n        moved: Boolean(layoutItem.moved),\n        static: Boolean(layoutItem.static),\n        // These can be null/undefined\n        isDraggable: layoutItem.isDraggable,\n        isResizable: layoutItem.isResizable,\n        resizeHandles: layoutItem.resizeHandles,\n        isBounded: layoutItem.isBounded\n    };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a, b) {\n    return (0,fast_equals__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(react__WEBPACK_IMPORTED_MODULE_0__.Children.map(a, c => c?.[\"key\"]), react__WEBPACK_IMPORTED_MODULE_0__.Children.map(b, c => c?.[\"key\"]));\n}\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a, b) {\n    return (a.left === b.left &&\n        a.top === b.top &&\n        a.width === b.width &&\n        a.height === b.height);\n}\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1, l2) {\n    if (l1.i === l2.i)\n        return false; // same element\n    if (l1.x + l1.w <= l2.x)\n        return false; // l1 is left of l2\n    if (l1.x >= l2.x + l2.w)\n        return false; // l1 is right of l2\n    if (l1.y + l1.h <= l2.y)\n        return false; // l1 is above l2\n    if (l1.y >= l2.y + l2.h)\n        return false; // l1 is below l2\n    return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout, compactType, cols, allowOverlap) {\n    // Statics go in the compareWith array right away so items flow around them.\n    const compareWith = getStatics(layout);\n    // We go through the items by row and column.\n    const sorted = sortLayoutItems(layout, compactType);\n    // Holding for new items.\n    const out = Array(layout.length);\n    for (let i = 0, len = sorted.length; i < len; i++) {\n        let l = cloneLayoutItem(sorted[i]);\n        // Don't move static elements\n        if (!l.static) {\n            l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n            // Add to comparison array. We only collide with items before this one.\n            // Statics are already in this array.\n            compareWith.push(l);\n        }\n        // Add to output array to make sure they still come out in the right order.\n        out[layout.indexOf(sorted[i])] = l;\n        // Clear moved flag, if it exists.\n        l.moved = false;\n    }\n    return out;\n}\nconst heightWidth = { x: \"w\", y: \"h\" };\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\n    const sizeProp = heightWidth[axis];\n    item[axis] += 1;\n    const itemIndex = layout\n        .map(layoutItem => {\n        return layoutItem.i;\n    })\n        .indexOf(item.i);\n    // Go through each item we collide with.\n    for (let i = itemIndex + 1; i < layout.length; i++) {\n        const otherItem = layout[i];\n        // Ignore static items\n        if (otherItem.static)\n            continue;\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (otherItem.y > item.y + item.h)\n            break;\n        if (collides(item, otherItem)) {\n            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n        }\n    }\n    item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith, l, compactType, cols, fullLayout, allowOverlap) {\n    const compactV = compactType === \"vertical\";\n    const compactH = compactType === \"horizontal\";\n    if (compactV) {\n        // Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element up as far as it can go without colliding.\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n            l.y--;\n        }\n    }\n    else if (compactH) {\n        // Move the element left as far as it can go without colliding.\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n            l.x--;\n        }\n    }\n    // Move it down, and keep moving it down if it's colliding.\n    let collides;\n    // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n    while ((collides = getFirstCollision(compareWith, l)) &&\n        !(compactType === null && allowOverlap)) {\n        if (compactH) {\n            resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n        }\n        else {\n            resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n        }\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n        if (compactH && l.x + l.w > cols) {\n            l.x = cols - l.w;\n            l.y++;\n            // ALso move element as left as we can\n            while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n                l.x--;\n            }\n        }\n    }\n    // Ensure that there are no negative positions\n    l.y = Math.max(l.y, 0);\n    l.x = Math.max(l.x, 0);\n    return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout, bounds) {\n    const collidesWith = getStatics(layout);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const l = layout[i];\n        // Overflows right\n        if (l.x + l.w > bounds.cols)\n            l.x = bounds.cols - l.w;\n        // Overflows left\n        if (l.x < 0) {\n            l.x = 0;\n            l.w = bounds.cols;\n        }\n        if (l.z == null) {\n            l.z = 0;\n        }\n        if (!l.static)\n            collidesWith.push(l);\n        else {\n            // If this is static and collides with other statics, we must move it down.\n            // We have to do something nicer than just letting them overlap.\n            while (getFirstCollision(collidesWith, l)) {\n                l.y++;\n            }\n        }\n    }\n    return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout, id) {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].i === id)\n            return layout[i];\n    }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout, layoutItem) {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem))\n            return layout[i];\n    }\n}\nfunction getAllCollisions(layout, layoutItem) {\n    return layout.filter(l => collides(l, layoutItem));\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout) {\n    return layout.filter(l => l.static);\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(properties) {\n    const { l, x, y, z, isUserAction, preventCollision, cols, compactType, allowOverlap } = properties;\n    let { layout } = properties;\n    // If this is static and not explicitly enabled as draggable,\n    // no move is possible, so we can short-circuit this immediately.\n    if (l.static && l.isDraggable !== true)\n        return layout;\n    // Short-circuit if nothing to do.\n    if (l.y === y && l.x === x && l.z === z)\n        return layout;\n    log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n    const oldX = l.x;\n    const oldY = l.y;\n    const oldZ = l.z;\n    // This is quite a bit faster than extending the object\n    if (typeof x === \"number\")\n        l.x = x;\n    if (typeof y === \"number\")\n        l.y = y;\n    if (typeof z === \"number\")\n        l.z = y;\n    l.moved = true;\n    // If this collides with anything, move it.\n    // When doing this comparison, we have to sort the items we compare with\n    // to ensure, in the case of multiple collisions, that we're getting the\n    // nearest collision.\n    let sorted = sortLayoutItems(layout, compactType);\n    const movingUp = compactType === \"vertical\" && typeof y === \"number\"\n        ? oldY >= y\n        : compactType === \"horizontal\" && typeof x === \"number\"\n            ? oldX >= x\n            : false;\n    // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n    if (movingUp)\n        sorted = sorted.reverse();\n    const collisions = getAllCollisions(sorted, l);\n    const hasCollisions = collisions.length > 0;\n    // We may have collisions. We can short-circuit if we've turned off collisions or\n    // allowed overlap.\n    if (hasCollisions && allowOverlap) {\n        // Easy, we don't need to resolve collisions. But we can make sure the newly movedo item appears on top!\n        const maxZ = Math.max(...collisions.map(x => x.z ?? Number.MIN_SAFE_INTEGER));\n        l.z = maxZ + 1;\n        return cloneLayout(layout);\n    }\n    else if (hasCollisions && preventCollision) {\n        // If we are preventing collision but not allowing overlap, we need to\n        // revert the position of this element so it goes to where it came from, rather\n        // than the user's desired location.\n        log(`Collision prevented on ${l.i}, reverting.`);\n        l.x = oldX;\n        l.y = oldY;\n        l.z = oldZ;\n        l.moved = false;\n        return layout; // did not change so don't clone\n    }\n    // Move each item that collides away from this element.\n    for (let i = 0, len = collisions.length; i < len; i++) {\n        const collision = collisions[i];\n        log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n        // Short circuit so we can't infinite loop\n        if (collision.moved)\n            continue;\n        // Don't move static items - we have to move *this* element away\n        if (collision.static) {\n            layout = moveElementAwayFromCollision({\n                layout,\n                collidesWith: collision,\n                itemToMove: l,\n                isUserAction,\n                compactType,\n                cols\n            });\n        }\n        else {\n            layout = moveElementAwayFromCollision({\n                layout,\n                collidesWith: l,\n                itemToMove: collision,\n                isUserAction,\n                compactType,\n                cols\n            });\n        }\n    }\n    return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(properties) {\n    const { collidesWith, cols, compactType, itemToMove, layout } = properties;\n    let { isUserAction } = properties;\n    const compactH = compactType === \"horizontal\";\n    // Compact vertically if not set to horizontal\n    const compactV = compactType !== \"horizontal\";\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n    // If there is enough space above the collision to put this element, move it there.\n    // We only do this on the main collision as this can get funky in cascades and cause\n    // unwanted swapping behavior.\n    if (isUserAction) {\n        // Reset isUserAction flag because we're not in the main collision anymore.\n        isUserAction = false;\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\n        const fakeItem = {\n            x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n            y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n            z: itemToMove.z,\n            w: itemToMove.w,\n            h: itemToMove.h,\n            i: \"-1\"\n        };\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n        if (!getFirstCollision(layout, fakeItem)) {\n            log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n            return moveElement({\n                layout,\n                l: itemToMove,\n                x: compactH ? fakeItem.x : undefined,\n                y: compactV ? fakeItem.y : undefined,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols\n            });\n        }\n    }\n    return moveElement({\n        layout,\n        l: itemToMove,\n        x: compactH ? itemToMove.x + 1 : undefined,\n        y: compactV ? itemToMove.y + 1 : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n    });\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num) {\n    return num * 100 + \"%\";\n}\nfunction setTransform({ top, left, z, width, height }) {\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`;\n    return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        zIndex: z,\n        position: \"absolute\"\n    };\n}\nfunction setTopLeft({ top, left, z, width, height }) {\n    return {\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        zIndex: z,\n        position: \"absolute\"\n    };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout, compactType) {\n    if (compactType === \"horizontal\")\n        return sortLayoutItemsByColRow(layout);\n    if (compactType === \"vertical\")\n        return sortLayoutItemsByRowCol(layout);\n    else\n        return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout) {\n    // Slice to clone array as sort modifies\n    return layout.slice(0).sort(function (a, b) {\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n            return 1;\n        }\n        else if (a.y === b.y && a.x === b.x) {\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0;\n        }\n        return -1;\n    });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout) {\n    return layout.slice(0).sort(function (a, b) {\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n            return 1;\n        }\n        return -1;\n    });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout, children, cols, compactType, allowOverlap) {\n    initialLayout = initialLayout || [];\n    // Generate one layout item per child.\n    const layout = [];\n    children &&\n        react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(Array.isArray(children) ? children : [children], (child) => {\n            // Child may not exist\n            if (child?.key == null)\n                return;\n            // Don't overwrite if it already exists.\n            const exists = getLayoutItem(initialLayout, String(child.key));\n            if (exists) {\n                layout.push(cloneLayoutItem(exists));\n            }\n            else {\n                if (!isProduction && child.props._grid) {\n                    console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" +\n                        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n                }\n                const g = child.props[\"data-grid\"] || child.props._grid;\n                // Hey, this item has a data-grid property, use it.\n                if (g) {\n                    if (!isProduction) {\n                        validateLayout([g], \"GridLayout.children\");\n                    }\n                    // FIXME clone not really necessary here\n                    layout.push(cloneLayoutItem({ ...g, i: child.key }));\n                }\n                else {\n                    // Nothing provided: ensure this is added to the bottom\n                    // FIXME clone not really necessary here\n                    layout.push(cloneLayoutItem({\n                        w: 1,\n                        h: 1,\n                        x: 0,\n                        y: bottom(layout),\n                        z: 0,\n                        i: String(child.key)\n                    }));\n                }\n            }\n        });\n    // Correct the layout.\n    const correctedLayout = correctBounds(layout, { cols: cols });\n    return allowOverlap\n        ? correctedLayout\n        : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout, contextName = \"Layout\") {\n    const subProps = [\"x\", \"y\", \"w\", \"h\"];\n    if (!Array.isArray(layout))\n        throw new Error(contextName + \" must be an array!\");\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const item = layout[i];\n        for (let j = 0; j < subProps.length; j++) {\n            if (typeof item[subProps[j]] !== \"number\") {\n                throw new Error(\"GridLayout: \" +\n                    contextName +\n                    \"[\" +\n                    i +\n                    \"].\" +\n                    subProps[j] +\n                    \" must be a number!\");\n            }\n        }\n    }\n}\nfunction log(...args) {\n    if (!DEBUG)\n        return;\n    // eslint-disable-next-line no-console\n    console.log(...args);\n}\nconst noop = (_args) => undefined;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDZDtBQUMxQixxQkFBcUIsYUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ087QUFDUDtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBUyxDQUFDLDJDQUFjLDBCQUEwQiwyQ0FBYztBQUMzRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQtbmV4dC9saWIvZXNtL3V0aWxzLmpzPzAwN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSBcImZhc3QtZXF1YWxzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG5jb25zdCBERUJVRyA9IGZhbHNlO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGJvdHRvbSBjb29yZGluYXRlIG9mIHRoZSBsYXlvdXQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIEJvdHRvbSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYm90dG9tKGxheW91dCkge1xuICAgIGxldCBtYXggPSAwLCBib3R0b21ZO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYm90dG9tWSA9IGxheW91dFtpXS55ICsgbGF5b3V0W2ldLmg7XG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4KVxuICAgICAgICAgICAgbWF4ID0gYm90dG9tWTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUxheW91dChsYXlvdXQpIHtcbiAgICBjb25zdCBuZXdMYXlvdXQgPSBBcnJheShsYXlvdXQubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5ld0xheW91dFtpXSA9IGNsb25lTGF5b3V0SXRlbShsYXlvdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TGF5b3V0O1xufVxuLy8gTW9kaWZ5IGEgbGF5b3V0SXRlbSBpbnNpZGUgYSBsYXlvdXQuIFJldHVybnMgYSBuZXcgTGF5b3V0LFxuLy8gZG9lcyBub3QgbXV0YXRlLiBDYXJyaWVzIG92ZXIgYWxsIG90aGVyIExheW91dEl0ZW1zIHVubW9kaWZpZWQuXG5leHBvcnQgZnVuY3Rpb24gbW9kaWZ5TGF5b3V0KGxheW91dCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGxheW91dEl0ZW0uaSA9PT0gbGF5b3V0W2ldLmkpIHtcbiAgICAgICAgICAgIG5ld0xheW91dFtpXSA9IGxheW91dEl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXlvdXRbaV0gPSBsYXlvdXRbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0xheW91dDtcbn1cbi8vIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byBtb2RpZnkgYSBsYXlvdXQgaXRlbS5cbi8vIERvZXMgZGVmZW5zaXZlIGNsb25lcyB0byBlbnN1cmUgdGhlIGxheW91dCBpcyBub3QgbW9kaWZpZWQuXG5leHBvcnQgZnVuY3Rpb24gd2l0aExheW91dEl0ZW0obGF5b3V0LCBpdGVtS2V5LCBjYikge1xuICAgIGxldCBpdGVtID0gZ2V0TGF5b3V0SXRlbShsYXlvdXQsIGl0ZW1LZXkpO1xuICAgIGlmICghaXRlbSlcbiAgICAgICAgcmV0dXJuIFtsYXlvdXQsIG51bGxdO1xuICAgIGl0ZW0gPSBjYihjbG9uZUxheW91dEl0ZW0oaXRlbSkpOyAvLyBkZWZlbnNpdmUgY2xvbmUgdGhlbiBtb2RpZnlcbiAgICAvLyBGSVhNRSBjb3VsZCBkbyB0aGlzIGZhc3RlciBpZiB3ZSBhbHJlYWR5IGtuZXcgdGhlIGluZGV4XG4gICAgbGF5b3V0ID0gbW9kaWZ5TGF5b3V0KGxheW91dCwgaXRlbSk7XG4gICAgcmV0dXJuIFtsYXlvdXQsIGl0ZW1dO1xufVxuLy8gRmFzdCBwYXRoIHRvIGNsb25pbmcsIHNpbmNlIHRoaXMgaXMgbW9ub21vcnBoaWNcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUxheW91dEl0ZW0obGF5b3V0SXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHc6IGxheW91dEl0ZW0udyxcbiAgICAgICAgaDogbGF5b3V0SXRlbS5oLFxuICAgICAgICB4OiBsYXlvdXRJdGVtLngsXG4gICAgICAgIHk6IGxheW91dEl0ZW0ueSxcbiAgICAgICAgejogbGF5b3V0SXRlbS56LFxuICAgICAgICBpOiBsYXlvdXRJdGVtLmksXG4gICAgICAgIG1pblc6IGxheW91dEl0ZW0ubWluVyxcbiAgICAgICAgbWF4VzogbGF5b3V0SXRlbS5tYXhXLFxuICAgICAgICBtaW5IOiBsYXlvdXRJdGVtLm1pbkgsXG4gICAgICAgIG1heEg6IGxheW91dEl0ZW0ubWF4SCxcbiAgICAgICAgbW92ZWQ6IEJvb2xlYW4obGF5b3V0SXRlbS5tb3ZlZCksXG4gICAgICAgIHN0YXRpYzogQm9vbGVhbihsYXlvdXRJdGVtLnN0YXRpYyksXG4gICAgICAgIC8vIFRoZXNlIGNhbiBiZSBudWxsL3VuZGVmaW5lZFxuICAgICAgICBpc0RyYWdnYWJsZTogbGF5b3V0SXRlbS5pc0RyYWdnYWJsZSxcbiAgICAgICAgaXNSZXNpemFibGU6IGxheW91dEl0ZW0uaXNSZXNpemFibGUsXG4gICAgICAgIHJlc2l6ZUhhbmRsZXM6IGxheW91dEl0ZW0ucmVzaXplSGFuZGxlcyxcbiAgICAgICAgaXNCb3VuZGVkOiBsYXlvdXRJdGVtLmlzQm91bmRlZFxuICAgIH07XG59XG4vKipcbiAqIENvbXBhcmluZyBSZWFjdCBgY2hpbGRyZW5gIGlzIGEgYml0IGRpZmZpY3VsdC4gVGhpcyBpcyBhIGdvb2Qgd2F5IHRvIGNvbXBhcmUgdGhlbS5cbiAqIFRoaXMgd2lsbCBjYXRjaCBkaWZmZXJlbmNlcyBpbiBrZXlzLCBvcmRlciwgYW5kIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBkZWVwRXF1YWwoUmVhY3QuQ2hpbGRyZW4ubWFwKGEsIGMgPT4gYz8uW1wia2V5XCJdKSwgUmVhY3QuQ2hpbGRyZW4ubWFwKGIsIGMgPT4gYz8uW1wia2V5XCJdKSk7XG59XG4vLyBMaWtlIHRoZSBhYm92ZSwgYnV0IGEgbG90IHNpbXBsZXIuXG5leHBvcnQgZnVuY3Rpb24gZmFzdFBvc2l0aW9uRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoYS5sZWZ0ID09PSBiLmxlZnQgJiZcbiAgICAgICAgYS50b3AgPT09IGIudG9wICYmXG4gICAgICAgIGEud2lkdGggPT09IGIud2lkdGggJiZcbiAgICAgICAgYS5oZWlnaHQgPT09IGIuaGVpZ2h0KTtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIGxheW91dGl0ZW1zLCBjaGVjayBpZiB0aGV5IGNvbGxpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xsaWRlcyhsMSwgbDIpIHtcbiAgICBpZiAobDEuaSA9PT0gbDIuaSlcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzYW1lIGVsZW1lbnRcbiAgICBpZiAobDEueCArIGwxLncgPD0gbDIueClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBsZWZ0IG9mIGwyXG4gICAgaWYgKGwxLnggPj0gbDIueCArIGwyLncpXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgcmlnaHQgb2YgbDJcbiAgICBpZiAobDEueSArIGwxLmggPD0gbDIueSlcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBhYm92ZSBsMlxuICAgIGlmIChsMS55ID49IGwyLnkgKyBsMi5oKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGJlbG93IGwyXG4gICAgcmV0dXJuIHRydWU7IC8vIGJveGVzIG92ZXJsYXBcbn1cbi8qKlxuICogR2l2ZW4gYSBsYXlvdXQsIGNvbXBhY3QgaXQuIFRoaXMgaW52b2x2ZXMgZ29pbmcgZG93biBlYWNoIHkgY29vcmRpbmF0ZSBhbmQgcmVtb3ZpbmcgZ2Fwc1xuICogYmV0d2VlbiBpdGVtcy5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgbGF5b3V0IGl0ZW1zIChjbG9uZXMpLiBDcmVhdGVzIGEgbmV3IGxheW91dCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IExheW91dC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcbiAqICAgdmVydGljYWxseS5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IGFsbG93T3ZlcmxhcCBXaGVuIGB0cnVlYCwgYWxsb3dzIG92ZXJsYXBwaW5nIGdyaWQgaXRlbXMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QobGF5b3V0LCBjb21wYWN0VHlwZSwgY29scywgYWxsb3dPdmVybGFwKSB7XG4gICAgLy8gU3RhdGljcyBnbyBpbiB0aGUgY29tcGFyZVdpdGggYXJyYXkgcmlnaHQgYXdheSBzbyBpdGVtcyBmbG93IGFyb3VuZCB0aGVtLlxuICAgIGNvbnN0IGNvbXBhcmVXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xuICAgIC8vIFdlIGdvIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IHJvdyBhbmQgY29sdW1uLlxuICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQsIGNvbXBhY3RUeXBlKTtcbiAgICAvLyBIb2xkaW5nIGZvciBuZXcgaXRlbXMuXG4gICAgY29uc3Qgb3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgbCA9IGNsb25lTGF5b3V0SXRlbShzb3J0ZWRbaV0pO1xuICAgICAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBlbGVtZW50c1xuICAgICAgICBpZiAoIWwuc3RhdGljKSB7XG4gICAgICAgICAgICBsID0gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGgsIGwsIGNvbXBhY3RUeXBlLCBjb2xzLCBzb3J0ZWQsIGFsbG93T3ZlcmxhcCk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gY29tcGFyaXNvbiBhcnJheS4gV2Ugb25seSBjb2xsaWRlIHdpdGggaXRlbXMgYmVmb3JlIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gU3RhdGljcyBhcmUgYWxyZWFkeSBpbiB0aGlzIGFycmF5LlxuICAgICAgICAgICAgY29tcGFyZVdpdGgucHVzaChsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdG8gb3V0cHV0IGFycmF5IHRvIG1ha2Ugc3VyZSB0aGV5IHN0aWxsIGNvbWUgb3V0IGluIHRoZSByaWdodCBvcmRlci5cbiAgICAgICAgb3V0W2xheW91dC5pbmRleE9mKHNvcnRlZFtpXSldID0gbDtcbiAgICAgICAgLy8gQ2xlYXIgbW92ZWQgZmxhZywgaWYgaXQgZXhpc3RzLlxuICAgICAgICBsLm1vdmVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5jb25zdCBoZWlnaHRXaWR0aCA9IHsgeDogXCJ3XCIsIHk6IFwiaFwiIH07XG4vKipcbiAqIEJlZm9yZSBtb3ZpbmcgaXRlbSBkb3duLCBpdCB3aWxsIGNoZWNrIGlmIHRoZSBtb3ZlbWVudCB3aWxsIGNhdXNlIGNvbGxpc2lvbnMgYW5kIG1vdmUgdGhvc2UgaXRlbXMgZG93biBiZWZvcmUuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGxheW91dCwgaXRlbSwgbW92ZVRvQ29vcmQsIGF4aXMpIHtcbiAgICBjb25zdCBzaXplUHJvcCA9IGhlaWdodFdpZHRoW2F4aXNdO1xuICAgIGl0ZW1bYXhpc10gKz0gMTtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBsYXlvdXRcbiAgICAgICAgLm1hcChsYXlvdXRJdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGxheW91dEl0ZW0uaTtcbiAgICB9KVxuICAgICAgICAuaW5kZXhPZihpdGVtLmkpO1xuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBpdGVtIHdlIGNvbGxpZGUgd2l0aC5cbiAgICBmb3IgKGxldCBpID0gaXRlbUluZGV4ICsgMTsgaSA8IGxheW91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvdGhlckl0ZW0gPSBsYXlvdXRbaV07XG4gICAgICAgIC8vIElnbm9yZSBzdGF0aWMgaXRlbXNcbiAgICAgICAgaWYgKG90aGVySXRlbS5zdGF0aWMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiB3ZSBjYW4gYnJlYWsgZWFybHkgaWYgd2Uga25vdyB3ZSdyZSBwYXN0IHRoaXMgZWxcbiAgICAgICAgLy8gV2UgY2FuIGRvIHRoaXMgYi9jIGl0J3MgYSBzb3J0ZWQgbGF5b3V0XG4gICAgICAgIGlmIChvdGhlckl0ZW0ueSA+IGl0ZW0ueSArIGl0ZW0uaClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoY29sbGlkZXMoaXRlbSwgb3RoZXJJdGVtKSkge1xuICAgICAgICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24obGF5b3V0LCBvdGhlckl0ZW0sIG1vdmVUb0Nvb3JkICsgaXRlbVtzaXplUHJvcF0sIGF4aXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGl0ZW1bYXhpc10gPSBtb3ZlVG9Db29yZDtcbn1cbi8qKlxuICogQ29tcGFjdCBhbiBpdGVtIGluIHRoZSBsYXlvdXQuXG4gKlxuICogTW9kaWZpZXMgaXRlbS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0SXRlbShjb21wYXJlV2l0aCwgbCwgY29tcGFjdFR5cGUsIGNvbHMsIGZ1bGxMYXlvdXQsIGFsbG93T3ZlcmxhcCkge1xuICAgIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIjtcbiAgICBjb25zdCBjb21wYWN0SCA9IGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIjtcbiAgICBpZiAoY29tcGFjdFYpIHtcbiAgICAgICAgLy8gQm90dG9tICd5JyBwb3NzaWJsZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBsYXlvdXQuXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBuaWNlIHN0dWZmIGxpa2Ugc3BlY2lmeSB7eTogSW5maW5pdHl9XG4gICAgICAgIC8vIFRoaXMgaXMgaGVyZSBiZWNhdXNlIHRoZSBsYXlvdXQgbXVzdCBiZSBzb3J0ZWQgaW4gb3JkZXIgdG8gZ2V0IHRoZSBjb3JyZWN0IGJvdHRvbSBgeWAuXG4gICAgICAgIGwueSA9IE1hdGgubWluKGJvdHRvbShjb21wYXJlV2l0aCksIGwueSk7XG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdXAgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICAgICAgd2hpbGUgKGwueSA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xuICAgICAgICAgICAgbC55LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcGFjdEgpIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCBsZWZ0IGFzIGZhciBhcyBpdCBjYW4gZ28gd2l0aG91dCBjb2xsaWRpbmcuXG4gICAgICAgIHdoaWxlIChsLnggPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICAgICAgICAgIGwueC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgaXQgZG93biwgYW5kIGtlZXAgbW92aW5nIGl0IGRvd24gaWYgaXQncyBjb2xsaWRpbmcuXG4gICAgbGV0IGNvbGxpZGVzO1xuICAgIC8vIENoZWNraW5nIHRoZSBjb21wYWN0VHlwZSBudWxsIHZhbHVlIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBsYXlvdXQgd2hlbiBvdmVybGFwcGluZyBpcyBhbGxvd2VkLlxuICAgIHdoaWxlICgoY29sbGlkZXMgPSBnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpICYmXG4gICAgICAgICEoY29tcGFjdFR5cGUgPT09IG51bGwgJiYgYWxsb3dPdmVybGFwKSkge1xuICAgICAgICBpZiAoY29tcGFjdEgpIHtcbiAgICAgICAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGZ1bGxMYXlvdXQsIGwsIGNvbGxpZGVzLnggKyBjb2xsaWRlcy53LCBcInhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihmdWxsTGF5b3V0LCBsLCBjb2xsaWRlcy55ICsgY29sbGlkZXMuaCwgXCJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGdyb3cgd2l0aG91dCBib3VuZHMgaG9yaXpvbnRhbGx5LCBpZiB3ZSd2ZSBvdmVyZmxvd24sIGxldCdzIG1vdmUgaXQgZG93biBhbmQgdHJ5IGFnYWluLlxuICAgICAgICBpZiAoY29tcGFjdEggJiYgbC54ICsgbC53ID4gY29scykge1xuICAgICAgICAgICAgbC54ID0gY29scyAtIGwudztcbiAgICAgICAgICAgIGwueSsrO1xuICAgICAgICAgICAgLy8gQUxzbyBtb3ZlIGVsZW1lbnQgYXMgbGVmdCBhcyB3ZSBjYW5cbiAgICAgICAgICAgIHdoaWxlIChsLnggPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICAgICAgICAgICAgICBsLngtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gbmVnYXRpdmUgcG9zaXRpb25zXG4gICAgbC55ID0gTWF0aC5tYXgobC55LCAwKTtcbiAgICBsLnggPSBNYXRoLm1heChsLngsIDApO1xuICAgIHJldHVybiBsO1xufVxuLyoqXG4gKiBHaXZlbiBhIGxheW91dCwgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBmaXQgd2l0aGluIGl0cyBib3VuZHMuXG4gKlxuICogTW9kaWZpZXMgbGF5b3V0IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHBhcmFtICB7TnVtYmVyfSBib3VuZHMgTnVtYmVyIG9mIGNvbHVtbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3JyZWN0Qm91bmRzKGxheW91dCwgYm91bmRzKSB7XG4gICAgY29uc3QgY29sbGlkZXNXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbCA9IGxheW91dFtpXTtcbiAgICAgICAgLy8gT3ZlcmZsb3dzIHJpZ2h0XG4gICAgICAgIGlmIChsLnggKyBsLncgPiBib3VuZHMuY29scylcbiAgICAgICAgICAgIGwueCA9IGJvdW5kcy5jb2xzIC0gbC53O1xuICAgICAgICAvLyBPdmVyZmxvd3MgbGVmdFxuICAgICAgICBpZiAobC54IDwgMCkge1xuICAgICAgICAgICAgbC54ID0gMDtcbiAgICAgICAgICAgIGwudyA9IGJvdW5kcy5jb2xzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsLnogPT0gbnVsbCkge1xuICAgICAgICAgICAgbC56ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWwuc3RhdGljKVxuICAgICAgICAgICAgY29sbGlkZXNXaXRoLnB1c2gobCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIGNvbGxpZGVzIHdpdGggb3RoZXIgc3RhdGljcywgd2UgbXVzdCBtb3ZlIGl0IGRvd24uXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGRvIHNvbWV0aGluZyBuaWNlciB0aGFuIGp1c3QgbGV0dGluZyB0aGVtIG92ZXJsYXAuXG4gICAgICAgICAgICB3aGlsZSAoZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlkZXNXaXRoLCBsKSkge1xuICAgICAgICAgICAgICAgIGwueSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXlvdXQ7XG59XG4vKipcbiAqIEdldCBhIGxheW91dCBpdGVtIGJ5IElELiBVc2VkIHNvIHdlIGNhbiBvdmVycmlkZSBsYXRlciBvbiBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgSURcbiAqIEByZXR1cm4ge0xheW91dEl0ZW19ICAgIEl0ZW0gYXQgSUQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXlvdXRJdGVtKGxheW91dCwgaWQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChsYXlvdXRbaV0uaSA9PT0gaWQpXG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0W2ldO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGlzIGxheW91dCBjb2xsaWRlcyB3aXRoLlxuICogSXQgZG9lc24ndCBhcHBlYXIgdG8gbWF0dGVyIHdoaWNoIG9yZGVyIHdlIGFwcHJvYWNoIHRoaXMgZnJvbSwgYWx0aG91Z2hcbiAqIHBlcmhhcHMgdGhhdCBpcyB0aGUgd3JvbmcgdGhpbmcgdG8gZG8uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBsYXlvdXRJdGVtIExheW91dCBpdGVtLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gIEEgY29sbGlkaW5nIGxheW91dCBpdGVtLCBvciB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihsYXlvdXQsIGxheW91dEl0ZW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjb2xsaWRlcyhsYXlvdXRbaV0sIGxheW91dEl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGxheW91dFtpXTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29sbGlzaW9ucyhsYXlvdXQsIGxheW91dEl0ZW0pIHtcbiAgICByZXR1cm4gbGF5b3V0LmZpbHRlcihsID0+IGNvbGxpZGVzKGwsIGxheW91dEl0ZW0pKTtcbn1cbi8qKlxuICogR2V0IGFsbCBzdGF0aWMgZWxlbWVudHMuXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBBcnJheSBvZiBzdGF0aWMgbGF5b3V0IGl0ZW1zLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpY3MobGF5b3V0KSB7XG4gICAgcmV0dXJuIGxheW91dC5maWx0ZXIobCA9PiBsLnN0YXRpYyk7XG59XG4vKipcbiAqIE1vdmUgYW4gZWxlbWVudC4gUmVzcG9uc2libGUgZm9yIGRvaW5nIGNhc2NhZGluZyBtb3ZlbWVudHMgb2Ygb3RoZXIgZWxlbWVudHMuXG4gKlxuICogTW9kaWZpZXMgbGF5b3V0IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGwgICAgICAgICAgICAgICAgIGVsZW1lbnQgdG8gbW92ZS5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt4XSAgICAgICAgICAgICAgIFggcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt5XSAgICAgICAgICAgICAgIFkgcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVFbGVtZW50KHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7IGwsIHgsIHksIHosIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29scywgY29tcGFjdFR5cGUsIGFsbG93T3ZlcmxhcCB9ID0gcHJvcGVydGllcztcbiAgICBsZXQgeyBsYXlvdXQgfSA9IHByb3BlcnRpZXM7XG4gICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIG5vdCBleHBsaWNpdGx5IGVuYWJsZWQgYXMgZHJhZ2dhYmxlLFxuICAgIC8vIG5vIG1vdmUgaXMgcG9zc2libGUsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0IHRoaXMgaW1tZWRpYXRlbHkuXG4gICAgaWYgKGwuc3RhdGljICYmIGwuaXNEcmFnZ2FibGUgIT09IHRydWUpXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3RoaW5nIHRvIGRvLlxuICAgIGlmIChsLnkgPT09IHkgJiYgbC54ID09PSB4ICYmIGwueiA9PT0geilcbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICBsb2coYE1vdmluZyBlbGVtZW50ICR7bC5pfSB0byBbJHtTdHJpbmcoeCl9LCR7U3RyaW5nKHkpfV0gZnJvbSBbJHtsLnh9LCR7bC55fV1gKTtcbiAgICBjb25zdCBvbGRYID0gbC54O1xuICAgIGNvbnN0IG9sZFkgPSBsLnk7XG4gICAgY29uc3Qgb2xkWiA9IGwuejtcbiAgICAvLyBUaGlzIGlzIHF1aXRlIGEgYml0IGZhc3RlciB0aGFuIGV4dGVuZGluZyB0aGUgb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKVxuICAgICAgICBsLnggPSB4O1xuICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgbC55ID0geTtcbiAgICBpZiAodHlwZW9mIHogPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGwueiA9IHk7XG4gICAgbC5tb3ZlZCA9IHRydWU7XG4gICAgLy8gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIGFueXRoaW5nLCBtb3ZlIGl0LlxuICAgIC8vIFdoZW4gZG9pbmcgdGhpcyBjb21wYXJpc29uLCB3ZSBoYXZlIHRvIHNvcnQgdGhlIGl0ZW1zIHdlIGNvbXBhcmUgd2l0aFxuICAgIC8vIHRvIGVuc3VyZSwgaW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgY29sbGlzaW9ucywgdGhhdCB3ZSdyZSBnZXR0aW5nIHRoZVxuICAgIC8vIG5lYXJlc3QgY29sbGlzaW9uLlxuICAgIGxldCBzb3J0ZWQgPSBzb3J0TGF5b3V0SXRlbXMobGF5b3V0LCBjb21wYWN0VHlwZSk7XG4gICAgY29uc3QgbW92aW5nVXAgPSBjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiICYmIHR5cGVvZiB5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gb2xkWSA+PSB5XG4gICAgICAgIDogY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiICYmIHR5cGVvZiB4ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IG9sZFggPj0geFxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAvLyAkRmxvd0lnbm9yZSBhY2NlcHRhYmxlIG1vZGlmaWNhdGlvbiBvZiByZWFkLW9ubHkgYXJyYXkgYXMgaXQgd2FzIHJlY2VudGx5IGNsb25lZFxuICAgIGlmIChtb3ZpbmdVcClcbiAgICAgICAgc29ydGVkID0gc29ydGVkLnJldmVyc2UoKTtcbiAgICBjb25zdCBjb2xsaXNpb25zID0gZ2V0QWxsQ29sbGlzaW9ucyhzb3J0ZWQsIGwpO1xuICAgIGNvbnN0IGhhc0NvbGxpc2lvbnMgPSBjb2xsaXNpb25zLmxlbmd0aCA+IDA7XG4gICAgLy8gV2UgbWF5IGhhdmUgY29sbGlzaW9ucy4gV2UgY2FuIHNob3J0LWNpcmN1aXQgaWYgd2UndmUgdHVybmVkIG9mZiBjb2xsaXNpb25zIG9yXG4gICAgLy8gYWxsb3dlZCBvdmVybGFwLlxuICAgIGlmIChoYXNDb2xsaXNpb25zICYmIGFsbG93T3ZlcmxhcCkge1xuICAgICAgICAvLyBFYXN5LCB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgY29sbGlzaW9ucy4gQnV0IHdlIGNhbiBtYWtlIHN1cmUgdGhlIG5ld2x5IG1vdmVkbyBpdGVtIGFwcGVhcnMgb24gdG9wIVxuICAgICAgICBjb25zdCBtYXhaID0gTWF0aC5tYXgoLi4uY29sbGlzaW9ucy5tYXAoeCA9PiB4LnogPz8gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKTtcbiAgICAgICAgbC56ID0gbWF4WiArIDE7XG4gICAgICAgIHJldHVybiBjbG9uZUxheW91dChsYXlvdXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNDb2xsaXNpb25zICYmIHByZXZlbnRDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIHByZXZlbnRpbmcgY29sbGlzaW9uIGJ1dCBub3QgYWxsb3dpbmcgb3ZlcmxhcCwgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZXZlcnQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBzbyBpdCBnb2VzIHRvIHdoZXJlIGl0IGNhbWUgZnJvbSwgcmF0aGVyXG4gICAgICAgIC8vIHRoYW4gdGhlIHVzZXIncyBkZXNpcmVkIGxvY2F0aW9uLlxuICAgICAgICBsb2coYENvbGxpc2lvbiBwcmV2ZW50ZWQgb24gJHtsLml9LCByZXZlcnRpbmcuYCk7XG4gICAgICAgIGwueCA9IG9sZFg7XG4gICAgICAgIGwueSA9IG9sZFk7XG4gICAgICAgIGwueiA9IG9sZFo7XG4gICAgICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGxheW91dDsgLy8gZGlkIG5vdCBjaGFuZ2Ugc28gZG9uJ3QgY2xvbmVcbiAgICB9XG4gICAgLy8gTW92ZSBlYWNoIGl0ZW0gdGhhdCBjb2xsaWRlcyBhd2F5IGZyb20gdGhpcyBlbGVtZW50LlxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG4gICAgICAgIGxvZyhgUmVzb2x2aW5nIGNvbGxpc2lvbiBiZXR3ZWVuICR7bC5pfSBhdCBbJHtsLnh9LCR7bC55fV0gYW5kICR7Y29sbGlzaW9uLml9IGF0IFske2NvbGxpc2lvbi54fSwke2NvbGxpc2lvbi55fV1gKTtcbiAgICAgICAgLy8gU2hvcnQgY2lyY3VpdCBzbyB3ZSBjYW4ndCBpbmZpbml0ZSBsb29wXG4gICAgICAgIGlmIChjb2xsaXNpb24ubW92ZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gRG9uJ3QgbW92ZSBzdGF0aWMgaXRlbXMgLSB3ZSBoYXZlIHRvIG1vdmUgKnRoaXMqIGVsZW1lbnQgYXdheVxuICAgICAgICBpZiAoY29sbGlzaW9uLnN0YXRpYykge1xuICAgICAgICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbih7XG4gICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgIGNvbGxpZGVzV2l0aDogY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGl0ZW1Ub01vdmU6IGwsXG4gICAgICAgICAgICAgICAgaXNVc2VyQWN0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBhY3RUeXBlLFxuICAgICAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbih7XG4gICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgIGNvbGxpZGVzV2l0aDogbCxcbiAgICAgICAgICAgICAgICBpdGVtVG9Nb3ZlOiBjb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgaXNVc2VyQWN0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBhY3RUeXBlLFxuICAgICAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXlvdXQ7XG59XG4vKipcbiAqIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIG5lZWRzIHRvIGhhcHBlbiAtIGdpdmVuIGEgY29sbGlzaW9uLCBtb3ZlIGFuIGVsZW1lbnQgYXdheSBmcm9tIHRoZSBjb2xsaXNpb24uXG4gKiBXZSBhdHRlbXB0IHRvIG1vdmUgaXQgdXAgaWYgdGhlcmUncyByb29tLCBvdGhlcndpc2UgaXQgZ29lcyBiZWxvdy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0ICAgICAgICAgICAgRnVsbCBsYXlvdXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gY29sbGlkZXNXaXRoIExheW91dCBpdGVtIHdlJ3JlIGNvbGxpZGluZyB3aXRoLlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gaXRlbVRvTW92ZSAgIExheW91dCBpdGVtIHdlJ3JlIG1vdmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24ocHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY29sbGlkZXNXaXRoLCBjb2xzLCBjb21wYWN0VHlwZSwgaXRlbVRvTW92ZSwgbGF5b3V0IH0gPSBwcm9wZXJ0aWVzO1xuICAgIGxldCB7IGlzVXNlckFjdGlvbiB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBjb21wYWN0SCA9IGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIjtcbiAgICAvLyBDb21wYWN0IHZlcnRpY2FsbHkgaWYgbm90IHNldCB0byBob3Jpem9udGFsXG4gICAgY29uc3QgY29tcGFjdFYgPSBjb21wYWN0VHlwZSAhPT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgcHJldmVudENvbGxpc2lvbiA9IGNvbGxpZGVzV2l0aC5zdGF0aWM7IC8vIHdlJ3JlIGFscmVhZHkgY29sbGlkaW5nIChub3QgZm9yIHN0YXRpYyBpdGVtcylcbiAgICAvLyBJZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgYWJvdmUgdGhlIGNvbGxpc2lvbiB0byBwdXQgdGhpcyBlbGVtZW50LCBtb3ZlIGl0IHRoZXJlLlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgbWFpbiBjb2xsaXNpb24gYXMgdGhpcyBjYW4gZ2V0IGZ1bmt5IGluIGNhc2NhZGVzIGFuZCBjYXVzZVxuICAgIC8vIHVud2FudGVkIHN3YXBwaW5nIGJlaGF2aW9yLlxuICAgIGlmIChpc1VzZXJBY3Rpb24pIHtcbiAgICAgICAgLy8gUmVzZXQgaXNVc2VyQWN0aW9uIGZsYWcgYmVjYXVzZSB3ZSdyZSBub3QgaW4gdGhlIG1haW4gY29sbGlzaW9uIGFueW1vcmUuXG4gICAgICAgIGlzVXNlckFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBNYWtlIGEgbW9jayBpdGVtIHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgaXRlbSBoZXJlLCBvbmx5IG1vZGlmeSBpbiBtb3ZlRWxlbWVudC5cbiAgICAgICAgY29uc3QgZmFrZUl0ZW0gPSB7XG4gICAgICAgICAgICB4OiBjb21wYWN0SCA/IE1hdGgubWF4KGNvbGxpZGVzV2l0aC54IC0gaXRlbVRvTW92ZS53LCAwKSA6IGl0ZW1Ub01vdmUueCxcbiAgICAgICAgICAgIHk6IGNvbXBhY3RWID8gTWF0aC5tYXgoY29sbGlkZXNXaXRoLnkgLSBpdGVtVG9Nb3ZlLmgsIDApIDogaXRlbVRvTW92ZS55LFxuICAgICAgICAgICAgejogaXRlbVRvTW92ZS56LFxuICAgICAgICAgICAgdzogaXRlbVRvTW92ZS53LFxuICAgICAgICAgICAgaDogaXRlbVRvTW92ZS5oLFxuICAgICAgICAgICAgaTogXCItMVwiXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vIGNvbGxpc2lvbj8gSWYgc28sIHdlIGNhbiBnbyB1cCB0aGVyZTsgb3RoZXJ3aXNlLCB3ZSdsbCBlbmQgdXAgbW92aW5nIGRvd24gYXMgbm9ybWFsXG4gICAgICAgIGlmICghZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0LCBmYWtlSXRlbSkpIHtcbiAgICAgICAgICAgIGxvZyhgRG9pbmcgcmV2ZXJzZSBjb2xsaXNpb24gb24gJHtpdGVtVG9Nb3ZlLml9IHVwIHRvIFske2Zha2VJdGVtLnh9LCR7ZmFrZUl0ZW0ueX1dLmApO1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KHtcbiAgICAgICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICAgICAgbDogaXRlbVRvTW92ZSxcbiAgICAgICAgICAgICAgICB4OiBjb21wYWN0SCA/IGZha2VJdGVtLnggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeTogY29tcGFjdFYgPyBmYWtlSXRlbS55IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlzVXNlckFjdGlvbixcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGNvbXBhY3RUeXBlLFxuICAgICAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3ZlRWxlbWVudCh7XG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbDogaXRlbVRvTW92ZSxcbiAgICAgICAgeDogY29tcGFjdEggPyBpdGVtVG9Nb3ZlLnggKyAxIDogdW5kZWZpbmVkLFxuICAgICAgICB5OiBjb21wYWN0ViA/IGl0ZW1Ub01vdmUueSArIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIGlzVXNlckFjdGlvbixcbiAgICAgICAgcHJldmVudENvbGxpc2lvbixcbiAgICAgICAgY29tcGFjdFR5cGUsXG4gICAgICAgIGNvbHNcbiAgICB9KTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBwZXJjZW50YWdlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG51bSBBbnkgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUaGF0IG51bWJlciBhcyBhIHBlcmNlbnRhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJjKG51bSkge1xuICAgIHJldHVybiBudW0gKiAxMDAgKyBcIiVcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oeyB0b3AsIGxlZnQsIHosIHdpZHRoLCBoZWlnaHQgfSkge1xuICAgIC8vIFJlcGxhY2UgdW5pdGxlc3MgaXRlbXMgd2l0aCBweFxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCR7dG9wfXB4KWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgICAgICBNb3pUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICAgICAgT1RyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgIHpJbmRleDogeixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0VG9wTGVmdCh7IHRvcCwgbGVmdCwgeiwgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBgJHt0b3B9cHhgLFxuICAgICAgICBsZWZ0OiBgJHtsZWZ0fXB4YCxcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgICAgICB6SW5kZXg6IHosXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgbGF5b3V0IGl0ZW1zIHNvcnRlZCBmcm9tIHRvcCBsZWZ0IHRvIHJpZ2h0IGFuZCBkb3duLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgTGF5b3V0LCBzb3J0ZWQgc3RhdGljIGl0ZW1zIGZpcnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpIHtcbiAgICBpZiAoY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKVxuICAgICAgICByZXR1cm4gc29ydExheW91dEl0ZW1zQnlDb2xSb3cobGF5b3V0KTtcbiAgICBpZiAoY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIilcbiAgICAgICAgcmV0dXJuIHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbGF5b3V0O1xufVxuLyoqXG4gKiBTb3J0IGxheW91dCBpdGVtcyBieSByb3cgYXNjZW5kaW5nIGFuZCBjb2x1bW4gYXNjZW5kaW5nLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBMYXlvdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQpIHtcbiAgICAvLyBTbGljZSB0byBjbG9uZSBhcnJheSBhcyBzb3J0IG1vZGlmaWVzXG4gICAgcmV0dXJuIGxheW91dC5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLnkgPiBiLnkgfHwgKGEueSA9PT0gYi55ICYmIGEueCA+IGIueCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEueSA9PT0gYi55ICYmIGEueCA9PT0gYi54KSB7XG4gICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMsIHdlIGNhbiBnZXQgZGlmZmVyZW50IHNvcnQgcmVzdWx0cyBpbiBJRSB2cy4gQ2hyb21lL0ZGXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSk7XG59XG4vKipcbiAqIFNvcnQgbGF5b3V0IGl0ZW1zIGJ5IGNvbHVtbiBhc2NlbmRpbmcgdGhlbiByb3cgYXNjZW5kaW5nLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBMYXlvdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyhsYXlvdXQpIHtcbiAgICByZXR1cm4gbGF5b3V0LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEueCA+IGIueCB8fCAoYS54ID09PSBiLnggJiYgYS55ID4gYi55KSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxheW91dCB1c2luZyB0aGUgaW5pdGlhbExheW91dCBhbmQgY2hpbGRyZW4gYXMgYSB0ZW1wbGF0ZS5cbiAqIE1pc3NpbmcgZW50cmllcyB3aWxsIGJlIGFkZGVkLCBleHRyYW5lb3VzIG9uZXMgd2lsbCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IGluaXRpYWxMYXlvdXQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBpbml0aWFsTGF5b3V0IExheW91dCBwYXNzZWQgaW4gdGhyb3VnaCBwcm9wcy5cbiAqIEBwYXJhbSAge1N0cmluZ30gYnJlYWtwb2ludCAgICBDdXJyZW50IHJlc3BvbnNpdmUgYnJlYWtwb2ludC5cbiAqIEBwYXJhbSAgez9TdHJpbmd9IGNvbXBhY3QgICAgICBDb21wYWN0aW9uIG9wdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICBXb3JraW5nIGxheW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKGluaXRpYWxMYXlvdXQsIGNoaWxkcmVuLCBjb2xzLCBjb21wYWN0VHlwZSwgYWxsb3dPdmVybGFwKSB7XG4gICAgaW5pdGlhbExheW91dCA9IGluaXRpYWxMYXlvdXQgfHwgW107XG4gICAgLy8gR2VuZXJhdGUgb25lIGxheW91dCBpdGVtIHBlciBjaGlsZC5cbiAgICBjb25zdCBsYXlvdXQgPSBbXTtcbiAgICBjaGlsZHJlbiAmJlxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIC8vIENoaWxkIG1heSBub3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChjaGlsZD8ua2V5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gZ2V0TGF5b3V0SXRlbShpbml0aWFsTGF5b3V0LCBTdHJpbmcoY2hpbGQua2V5KSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0LnB1c2goY2xvbmVMYXlvdXRJdGVtKGV4aXN0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2R1Y3Rpb24gJiYgY2hpbGQucHJvcHMuX2dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYF9ncmlkYCBwcm9wZXJ0aWVzIG9uIGNoaWxkcmVuIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIFJlYWN0IDE1LjIuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSBgZGF0YS1ncmlkYCBvciBhZGQgeW91ciBwcm9wZXJ0aWVzIGRpcmVjdGx5IHRvIHRoZSBgbGF5b3V0YC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBjaGlsZC5wcm9wc1tcImRhdGEtZ3JpZFwiXSB8fCBjaGlsZC5wcm9wcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICAvLyBIZXksIHRoaXMgaXRlbSBoYXMgYSBkYXRhLWdyaWQgcHJvcGVydHksIHVzZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVMYXlvdXQoW2ddLCBcIkdyaWRMYXlvdXQuY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgY2xvbmUgbm90IHJlYWxseSBuZWNlc3NhcnkgaGVyZVxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQucHVzaChjbG9uZUxheW91dEl0ZW0oeyAuLi5nLCBpOiBjaGlsZC5rZXkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBwcm92aWRlZDogZW5zdXJlIHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBjbG9uZSBub3QgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBib3R0b20obGF5b3V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpOiBTdHJpbmcoY2hpbGQua2V5KVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAvLyBDb3JyZWN0IHRoZSBsYXlvdXQuXG4gICAgY29uc3QgY29ycmVjdGVkTGF5b3V0ID0gY29ycmVjdEJvdW5kcyhsYXlvdXQsIHsgY29sczogY29scyB9KTtcbiAgICByZXR1cm4gYWxsb3dPdmVybGFwXG4gICAgICAgID8gY29ycmVjdGVkTGF5b3V0XG4gICAgICAgIDogY29tcGFjdChjb3JyZWN0ZWRMYXlvdXQsIGNvbXBhY3RUeXBlLCBjb2xzKTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSBsYXlvdXQuIFRocm93cyBlcnJvcnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgICAgICAgIEFycmF5IG9mIGxheW91dCBpdGVtcy5cbiAqIEBwYXJhbSAge1N0cmluZ30gW2NvbnRleHROYW1lXSBDb250ZXh0IG5hbWUgZm9yIGVycm9ycy5cbiAqIEB0aHJvdyAge0Vycm9yfSAgICAgICAgICAgICAgICBWYWxpZGF0aW9uIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXQobGF5b3V0LCBjb250ZXh0TmFtZSA9IFwiTGF5b3V0XCIpIHtcbiAgICBjb25zdCBzdWJQcm9wcyA9IFtcInhcIiwgXCJ5XCIsIFwid1wiLCBcImhcIl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGxheW91dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb250ZXh0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXkhXCIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxheW91dFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdWJQcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtW3N1YlByb3BzW2pdXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdyaWRMYXlvdXQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIltcIiArXG4gICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICBcIl0uXCIgK1xuICAgICAgICAgICAgICAgICAgICBzdWJQcm9wc1tqXSArXG4gICAgICAgICAgICAgICAgICAgIFwiIG11c3QgYmUgYSBudW1iZXIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcbiAgICBpZiAoIURFQlVHKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cbmV4cG9ydCBjb25zdCBub29wID0gKF9hcmdzKSA9PiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout-next/lib/esm/utils.js\n");

/***/ })

};
;